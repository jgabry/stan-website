[
  {
    "objectID": "mc-stan-org/developers.html",
    "href": "mc-stan-org/developers.html",
    "title": "Stan Project’s Software Development Lifecycle",
    "section": "",
    "text": "The development, release, and maintenance of Stan is a collaborative process involving the Stan development team. The team covers multiple statistical and computational disciplines and its members work in academia, industry, or both. The Stan project employs standard software development, code review, and testing methodologies.\nThis document describes the software development lifecycle (SDLC) for projects managed by the Stan project and hosted by Stan’s GitHub organization stan-dev. Projects covered include the math library, core C++ algorithms, parser and code generator, and all of the interface and visualization packages.\nThe layout and content of this document very closely follows the R regulatory compliance and validation document.\n\n\nCommunication among team members takes place in several venues. Most discussions take place openly on the Stan forum.\n\nStan’s forum is hosted by Discourse at http://discourse.mc-stan.org\n\nThe Stan forums are archived and may be read by anyone at any time. Communication that’s not suitable for the public, such as grant funding, is carried out on a private group restricted to the core Stan developers. Further issue-specific discussion takes place concurrently with development and source control.\n\nStan’s issue trackers are hosted by GitHub.\n\nBigger design issues require design documents in the form of a community RFC.\n\nstan/dev:design-docs is hosted on GitHub\n\nVarious project meetings among developers and users take place online in various forums including Zoom and Google Hangouts. These are not recorded or stored. Developers also meet informally at their places of employment or at conferences and workshops when multiple team members are in attendance. The developers also host meetups for the public in locations including Berlin, Boston, London, Sydney, and New York.\n\n\n\nStan’s C++ library and the CmdStan interface are released under the terms of the new (3 clause) BSD license, with two dependent libraries (Boost and Eigen), released under compatible libraries. The R interface RStan and Python interface PyStan are released under the GPLv3 license.\n\n\n\nThe size of the Stan community is difficult to estimate reliably because there are no sales transactions and Stan’s version control distribution system (GitHub) does not provide download statistics. There were over 2000 users subscribed the users group on Google before it was moved to Discourse, on which there are dozens of active threads at any given time. This substantial user base provides the means to do continuous reviews of real-world performance in real settings. Unlike proprietary software only available in binary form, Stan’s open-source code base allows users to provide feedback at the code and documentation level.\n\n\n\n\n\n\nAll of the code is hosted on public version control repositories and may be reviewed at any time by all members of the Stan community. This allows continuous feedback for both coding standards, functionality, and statistical accuracy.\nThe source code for Stan’s C++ library, CmdStan, PyStan, and RStan is managed in separate version-control libraries based on Git and hosted by GitHub under the GitHub organization stan-dev:\n\nhttps://github.com/stan-dev\n\nPush access (i.e., the ability to write to the repository, specifically in approving pull requests and merging) is restricted to core developers and very closely managed. At the same time, any user may provide (and many users have provided) pull requests with patches for the system (which are treated as any other pull request and fully tested and code reviewed). Because of Git’s distributed nature, everyone who clones a repository produces a full backup of the system and all past versions.\nStan follows the Git process outlined by Vincent Driessen in his blog post, a successful branching model for Git.\nNew features and ordinary (not hot) bugfixes are developed in branches from and merged back into the development branch. These are then collected into releases and merged with the master branch, which tracks the releases. Hotfix branches are like feature or ordinary bugfix branches, but branch from master and merge back into master.\nThe basic Git process for branching, releasing, hotfixing, and merging follows standard Git procedure. A diagram outlining the process is presented in the figure above. The key idea is that the master branch is always at the latest release, with older commits tagged for previous releases.\nThe development branch always represents the current state of development. Feature and bugfix branches branch from the development branch. Before being merged back into the development branch, they must be wrapped in a pull request for GitHub, which supplies differences with current code and a forum for code review and comment on the issue. All branches must have appropriate unit tests and documentation as part of their pull request before they will be merged (see the pull request template, which all requests must follow). Each pull request must provide a summary of the change, a detailed description of the intended effect (often coupled with pointers to one or more issues on the issue tracker and one or more Wiki pages), a description of how the change was tested and its effects can be verified, a description of any side effects, a description of any user-facing documentation changes, and suggestions for reviewers.\nTaken together, the testing, code review, and merge process ensures that the development branch is always in a releasable state.\nGit itself provides extensive log facilities for comparing changes made in any given commit (which has a unique ID under Git) with any other commit, including the current development or master branch. GitHub provides further graphical facilities for commentary and graphical differences.\nFor each release, the Git logs are scanned and a set of user-facing release notes provided summarizing the changes. The full set of changes, including differences with previous versions, is available through Git. These logs are complete back to the first version of Stan, which was originally managed under the Subversion version control system.\nMore information on the mechanics of the process are available from on the Developer process Wiki.\n\n\n\n\n\nStan C++, CmdStan, PyStan, and RStan are all extensively unit tested. The core C++ code and CmdStan code is tested directly in C++ using the Google test framework . PyStan is tested using the Python unit testing framework unittest.\nRStan is tested using the RUnit package.\nThe point of unit testing is to test the program at the application programmer interface (API) level, not the end-to-end functional level.\nThe tests are run automatically when pull requests are created through a continuous integration process. Stan packages use a combination of the Travis continuous integration framework and the Jenkins continuous integration framework.\nThe continuous integration servers provide detailed reports of the various tests they run and whether they succeeded or failed. If they failed, console output is available pointing to the failed tests. The continuous integration servers also provide graphs and charts summarizing ongoing and past testing behavior.\nStan and its interfaces’ unit tests are all distributed with the system software and may be run by users on their specific platform with their specific compilers and configurations to provide support for the reliability of a particular installation of Stan.\nAs with any statistical software, users need to be careful to consider the appropriateness of the statistical model, the ability to fit it with existing data, and its suitability to its intended application.\nThe entire source repository is available to users. A snapshot at any given release (or commit within a branch) may be downloaded as an archive (zip file) or may be cloned for development under Git. Cloning in Git provides a complete copy of all version history, including every commit to every branch since the beginning of the project.\nUser feedback is accommodated through three channels. First, and most formally, there is an issue tracker for each of Stan C++, CmdStan, RStan and PyStan, which allows users to submit formal bug reports or make feature requests. Any user bug report is reviewed by the development team, assessed for validity and reproducibility, and assigned to a specific developer for a particular release target. A second route for reporting bugs is our users group; bugs reported to the user group by users are then submitted to the issue tracker by the developers and then put through the usual process. A third method of bug reporting is informal e-mail or comments; like the user group reports, these are channeled through the issue tracker by the developers before being tackled.\nContinuous integration is run on a combination of Windows, Mac OS X, and Linux platforms. All core Stan C++ code is tested on Windows, Mac OS, and Linux before release.\n\n\n\nIn addition to unit testing at the individual function level, Stan undergoes rigorous end-to-end testing of its model fitting functionality. Models with known answers are evaluated for both speed and accuracy. Models without analytic solutions are evaluated in terms of MCMC error.\n\n\n\n\nAt various stages, typically when major new functionality has been added or a serious bug has been fixed, the development branch is declared ready for release by the Stan development team. At this point, the branch is tested one last time on all platforms before being merged with the master branch. Releases are managed through GitHub releases mechanism. For example, releases for Stan C++ are available as GitHub releases. Each release further bundles the manual and provides both a zipped and tar-gzipped archive of the release.\nStan is released exclusively as source code, so nothing needs to be done with respect to binary release management or compatibility. The source is tested so that it can be used under Windows, Mac OS X, and Linux.\nInstructions for installing Stan C++, CmdStan, RStan, and PyStan are managed separately and distributed with the associated product.\n\n\n\nStan version numbers follow the standard semantic version numbering pattern in which version numbers are of the form Major.Minor.Patch. For example, version 2.9.1 is major release 2, minor release 9, and patch release 1. Semantic versioning signals important information about features and compatibility for the Stan language and how it is used. It does not provide information about underlying implementation; changes in implementation do not affect version numbering in and of itself.\nThe reference manual lists deprecated features in an appendix.\n\n\nA change in a library breaks backward compatibility if a program using only supported APIs (for Stan, that is the language reference; click here for the Math library) that worked in the previous version no longer works the same way in the current version. For backward-compatibility breaking changes, the major version number is incremented. When the major version is updated, the minor version reverts to 0. Because breaking backward compatibility is such a disturbance for users, there are very few major releases.\n\n\n\nA change in a library introduces a new feature if a program that works in the current version will not work in a previous version; that is, it breaks forward compatibility. When a version introduces a new feature without breaking backward compatibility, its minor version number is incremented. Whenever the minor version is incremented, the patch level reverts to 0. Most Stan releases increment the minor version.\n\n\n\nIf a release does not add new functionality or break backward compatibility, only its patch version is incremented. Patch releases of Stan are made when an important bug is fixed before any new work is done. Because Stan keeps its development branch clean, pending patches are easily rolled into minor releases."
  },
  {
    "objectID": "mc-stan-org/developers.html#communication",
    "href": "mc-stan-org/developers.html#communication",
    "title": "Stan Project’s Software Development Lifecycle",
    "section": "",
    "text": "Communication among team members takes place in several venues. Most discussions take place openly on the Stan forum.\n\nStan’s forum is hosted by Discourse at http://discourse.mc-stan.org\n\nThe Stan forums are archived and may be read by anyone at any time. Communication that’s not suitable for the public, such as grant funding, is carried out on a private group restricted to the core Stan developers. Further issue-specific discussion takes place concurrently with development and source control.\n\nStan’s issue trackers are hosted by GitHub.\n\nBigger design issues require design documents in the form of a community RFC.\n\nstan/dev:design-docs is hosted on GitHub\n\nVarious project meetings among developers and users take place online in various forums including Zoom and Google Hangouts. These are not recorded or stored. Developers also meet informally at their places of employment or at conferences and workshops when multiple team members are in attendance. The developers also host meetups for the public in locations including Berlin, Boston, London, Sydney, and New York."
  },
  {
    "objectID": "mc-stan-org/developers.html#licensing",
    "href": "mc-stan-org/developers.html#licensing",
    "title": "Stan Project’s Software Development Lifecycle",
    "section": "",
    "text": "Stan’s C++ library and the CmdStan interface are released under the terms of the new (3 clause) BSD license, with two dependent libraries (Boost and Eigen), released under compatible libraries. The R interface RStan and Python interface PyStan are released under the GPLv3 license."
  },
  {
    "objectID": "mc-stan-org/developers.html#community-size",
    "href": "mc-stan-org/developers.html#community-size",
    "title": "Stan Project’s Software Development Lifecycle",
    "section": "",
    "text": "The size of the Stan community is difficult to estimate reliably because there are no sales transactions and Stan’s version control distribution system (GitHub) does not provide download statistics. There were over 2000 users subscribed the users group on Google before it was moved to Discourse, on which there are dozens of active threads at any given time. This substantial user base provides the means to do continuous reviews of real-world performance in real settings. Unlike proprietary software only available in binary form, Stan’s open-source code base allows users to provide feedback at the code and documentation level."
  },
  {
    "objectID": "mc-stan-org/developers.html#hosting-and-version-control",
    "href": "mc-stan-org/developers.html#hosting-and-version-control",
    "title": "Stan Project’s Software Development Lifecycle",
    "section": "",
    "text": "All of the code is hosted on public version control repositories and may be reviewed at any time by all members of the Stan community. This allows continuous feedback for both coding standards, functionality, and statistical accuracy.\nThe source code for Stan’s C++ library, CmdStan, PyStan, and RStan is managed in separate version-control libraries based on Git and hosted by GitHub under the GitHub organization stan-dev:\n\nhttps://github.com/stan-dev\n\nPush access (i.e., the ability to write to the repository, specifically in approving pull requests and merging) is restricted to core developers and very closely managed. At the same time, any user may provide (and many users have provided) pull requests with patches for the system (which are treated as any other pull request and fully tested and code reviewed). Because of Git’s distributed nature, everyone who clones a repository produces a full backup of the system and all past versions.\nStan follows the Git process outlined by Vincent Driessen in his blog post, a successful branching model for Git.\nNew features and ordinary (not hot) bugfixes are developed in branches from and merged back into the development branch. These are then collected into releases and merged with the master branch, which tracks the releases. Hotfix branches are like feature or ordinary bugfix branches, but branch from master and merge back into master.\nThe basic Git process for branching, releasing, hotfixing, and merging follows standard Git procedure. A diagram outlining the process is presented in the figure above. The key idea is that the master branch is always at the latest release, with older commits tagged for previous releases.\nThe development branch always represents the current state of development. Feature and bugfix branches branch from the development branch. Before being merged back into the development branch, they must be wrapped in a pull request for GitHub, which supplies differences with current code and a forum for code review and comment on the issue. All branches must have appropriate unit tests and documentation as part of their pull request before they will be merged (see the pull request template, which all requests must follow). Each pull request must provide a summary of the change, a detailed description of the intended effect (often coupled with pointers to one or more issues on the issue tracker and one or more Wiki pages), a description of how the change was tested and its effects can be verified, a description of any side effects, a description of any user-facing documentation changes, and suggestions for reviewers.\nTaken together, the testing, code review, and merge process ensures that the development branch is always in a releasable state.\nGit itself provides extensive log facilities for comparing changes made in any given commit (which has a unique ID under Git) with any other commit, including the current development or master branch. GitHub provides further graphical facilities for commentary and graphical differences.\nFor each release, the Git logs are scanned and a set of user-facing release notes provided summarizing the changes. The full set of changes, including differences with previous versions, is available through Git. These logs are complete back to the first version of Stan, which was originally managed under the Subversion version control system.\nMore information on the mechanics of the process are available from on the Developer process Wiki."
  },
  {
    "objectID": "mc-stan-org/developers.html#testing-and-validation",
    "href": "mc-stan-org/developers.html#testing-and-validation",
    "title": "Stan Project’s Software Development Lifecycle",
    "section": "",
    "text": "Stan C++, CmdStan, PyStan, and RStan are all extensively unit tested. The core C++ code and CmdStan code is tested directly in C++ using the Google test framework . PyStan is tested using the Python unit testing framework unittest.\nRStan is tested using the RUnit package.\nThe point of unit testing is to test the program at the application programmer interface (API) level, not the end-to-end functional level.\nThe tests are run automatically when pull requests are created through a continuous integration process. Stan packages use a combination of the Travis continuous integration framework and the Jenkins continuous integration framework.\nThe continuous integration servers provide detailed reports of the various tests they run and whether they succeeded or failed. If they failed, console output is available pointing to the failed tests. The continuous integration servers also provide graphs and charts summarizing ongoing and past testing behavior.\nStan and its interfaces’ unit tests are all distributed with the system software and may be run by users on their specific platform with their specific compilers and configurations to provide support for the reliability of a particular installation of Stan.\nAs with any statistical software, users need to be careful to consider the appropriateness of the statistical model, the ability to fit it with existing data, and its suitability to its intended application.\nThe entire source repository is available to users. A snapshot at any given release (or commit within a branch) may be downloaded as an archive (zip file) or may be cloned for development under Git. Cloning in Git provides a complete copy of all version history, including every commit to every branch since the beginning of the project.\nUser feedback is accommodated through three channels. First, and most formally, there is an issue tracker for each of Stan C++, CmdStan, RStan and PyStan, which allows users to submit formal bug reports or make feature requests. Any user bug report is reviewed by the development team, assessed for validity and reproducibility, and assigned to a specific developer for a particular release target. A second route for reporting bugs is our users group; bugs reported to the user group by users are then submitted to the issue tracker by the developers and then put through the usual process. A third method of bug reporting is informal e-mail or comments; like the user group reports, these are channeled through the issue tracker by the developers before being tackled.\nContinuous integration is run on a combination of Windows, Mac OS X, and Linux platforms. All core Stan C++ code is tested on Windows, Mac OS, and Linux before release.\n\n\n\nIn addition to unit testing at the individual function level, Stan undergoes rigorous end-to-end testing of its model fitting functionality. Models with known answers are evaluated for both speed and accuracy. Models without analytic solutions are evaluated in terms of MCMC error."
  },
  {
    "objectID": "mc-stan-org/developers.html#release-cycles",
    "href": "mc-stan-org/developers.html#release-cycles",
    "title": "Stan Project’s Software Development Lifecycle",
    "section": "",
    "text": "At various stages, typically when major new functionality has been added or a serious bug has been fixed, the development branch is declared ready for release by the Stan development team. At this point, the branch is tested one last time on all platforms before being merged with the master branch. Releases are managed through GitHub releases mechanism. For example, releases for Stan C++ are available as GitHub releases. Each release further bundles the manual and provides both a zipped and tar-gzipped archive of the release.\nStan is released exclusively as source code, so nothing needs to be done with respect to binary release management or compatibility. The source is tested so that it can be used under Windows, Mac OS X, and Linux.\nInstructions for installing Stan C++, CmdStan, RStan, and PyStan are managed separately and distributed with the associated product."
  },
  {
    "objectID": "mc-stan-org/developers.html#versioning-and-release-compatibility",
    "href": "mc-stan-org/developers.html#versioning-and-release-compatibility",
    "title": "Stan Project’s Software Development Lifecycle",
    "section": "",
    "text": "Stan version numbers follow the standard semantic version numbering pattern in which version numbers are of the form Major.Minor.Patch. For example, version 2.9.1 is major release 2, minor release 9, and patch release 1. Semantic versioning signals important information about features and compatibility for the Stan language and how it is used. It does not provide information about underlying implementation; changes in implementation do not affect version numbering in and of itself.\nThe reference manual lists deprecated features in an appendix.\n\n\nA change in a library breaks backward compatibility if a program using only supported APIs (for Stan, that is the language reference; click here for the Math library) that worked in the previous version no longer works the same way in the current version. For backward-compatibility breaking changes, the major version number is incremented. When the major version is updated, the minor version reverts to 0. Because breaking backward compatibility is such a disturbance for users, there are very few major releases.\n\n\n\nA change in a library introduces a new feature if a program that works in the current version will not work in a previous version; that is, it breaks forward compatibility. When a version introduces a new feature without breaking backward compatibility, its minor version number is incremented. Whenever the minor version is incremented, the patch level reverts to 0. Most Stan releases increment the minor version.\n\n\n\nIf a release does not add new functionality or break backward compatibility, only its patch version is incremented. Patch releases of Stan are made when an important bug is fixed before any new work is done. Because Stan keeps its development branch clean, pending patches are easily rolled into minor releases."
  },
  {
    "objectID": "mc-stan-org/developers.html#availability-of-current-and-historical-archive-versions",
    "href": "mc-stan-org/developers.html#availability-of-current-and-historical-archive-versions",
    "title": "Stan Project’s Software Development Lifecycle",
    "section": "Availability of current and historical archive versions",
    "text": "Availability of current and historical archive versions\nCurrent and older versions of Stan C++, CmdStan, RStan, and PyStan are available through the GitHub pages for the corresponding repository. Official releases are bundled as archives and available through GitHub’s releases.\nAny intermediate commit is also available through GitHub in one of two ways. First, all of Stan (or CmdStan, RStan, or PyStan) may be downloaded by cloning the repository, at which point a user has a complete record of the entire project’s commits and branches. After first cloning a repository, it may be kept up to date using Git’s pull command (available from the command-line or platform-specific graphical user interfaces). An alternative delivery mechanism is as a zip archive of a snapshot of the system."
  },
  {
    "objectID": "mc-stan-org/developers.html#maintenance-support-and-retirement",
    "href": "mc-stan-org/developers.html#maintenance-support-and-retirement",
    "title": "Stan Project’s Software Development Lifecycle",
    "section": "Maintenance, support, and retirement",
    "text": "Maintenance, support, and retirement\nStan support extends only to the most current release. Specifically, patches are not backported to older versions.\nEarly fixes of bugs are available to users in the form of updated development branches. Snapshots of the entire code base at every commit, including development patches and official releases, are available from GitHub. Git itself may be used to download a complete clone of the entire source code history at any time.\nThere is extensive documentation in the form of manuals available for the Stan language and algorithms. There is also extensive interface documentation as well as the interfaces for the command line, R, Python, MATLAB, Mathematica, Stata, Julia, and Scala\nThere is also an extensive suite of tutorials and example models, which may be used directly or modified by users. There is also a fairly extensive set of Wiki pages for developers.\nIssue trackers for reporting bugs and requesting features are available online for Stan’s C++ math library and core library, as well as for the interfaces (all available from the stan-dev organization page.\nThere is Stan forum for users and developers. The users topics allow users can request support for installation issues, modeling issues, or performance/accuracy issues. These lists all come with built-in search facilities through their host or simply through top-level web searches in the search engine of your choice.\nA number of books provide introductions to Stan, including Gelman et al.’s Bayesian Data Analysis, 3rd Edition, Krushcke’s Doing Bayesian Data Analysis, 2nd Edition, and McElreath’s Statistical Rethinking. All of the examples from several other books have been translated to Stan, including Lee and Wagnemakers’ Bayesian Cognitive Modeling: A Practical Course, Lunn et al.’s The BUGS Book, Gelman and Hill’s Data Analysis Using Regression and Multilevel-Hierarchical Models, and Kéry Schaub’s Bayesian population analysis using WinBUGS.\nThe major.minor.0 releases are maintained through patch releases major.minor.n releases. At each new major.minor.0 release, prior versions are retired from support. All efforts are focused on the current release. No further development or bug fixes are made available for earlier versions. The earlier versions can still be accessed through version control."
  },
  {
    "objectID": "mc-stan-org/developers.html#qualified-personnel",
    "href": "mc-stan-org/developers.html#qualified-personnel",
    "title": "Stan Project’s Software Development Lifecycle",
    "section": "Qualified personnel",
    "text": "Qualified personnel\nThe members of the Stan development team are drawn from multiple computational, scientific, and statistical disciplines across academic, not-for-profit, and industrial laboratories.\nMany of Stan’s developers have Ph.D. degrees, some have Master’s degrees, and some are currently enrolled as undergraduate or graduate students. All of the developers with advanced degrees have published extensively in peer reviewed journals. Several have written books on statistics and/or computing. Many members of the core development team were well known internationally outside of their contributions to Stan. The group overall is widely acknowledged as leading experts in statistical computing, software development, and applied statistics.\nThe managers of the development process have extensive industrial programming experience and have designed or contributed to other software systems that are still in production.\nInstitutions at which the members of the Stan development team hold appointments as of Stan release 2.17.1 include Columbia University, Adobe Creative Technologies Lab, University of Warwick, University of Toronto (Scarborough), Dartmouth College, University of Washington, Lucidworks, CNRS (Paris), St. George’s, University of London, University of Massachusetts (Amherst), Aalto University, and Novartis Pharma."
  },
  {
    "objectID": "mc-stan-org/developers.html#physical-and-logical-security",
    "href": "mc-stan-org/developers.html#physical-and-logical-security",
    "title": "Stan Project’s Software Development Lifecycle",
    "section": "Physical and logical security",
    "text": "Physical and logical security\nThe Stan project maintains its integration servers for Stan C++ and CmdStan on site at Columbia University. The integration servers for Stan C++ and CmdStan are password protected and run on isolated, standalone machines used only as integration servers. The network is maintained by Columbia University’s Information Technology (CUIT) group.\nThe integration server for PyStan is hosted by the Travis open-source continuous integration project, and is password protected on an account basis.\nThe version control system is hosted by GitHub. Due to Git’s distributed nature, each developer maintains a complete record of the entire project’s commit history. Everything is openly available, but privileges to modify the existing branches is restricted to the core developers. Any change to the code base is easily reversed through Git.\nThe archived releases as well as clones of the full repositories are also managed through GitHub.\nStan’s web pages are also served by GitHub and are password protected. The web pages are purely informational and nothing is distributed through the web pages themselves other than case studies and documentation.\nIndividual contributors work on their own personal computers or on compute clusters at Columbia or elsewhere."
  },
  {
    "objectID": "mc-stan-org/developers.html#disaster-recovery",
    "href": "mc-stan-org/developers.html#disaster-recovery",
    "title": "Stan Project’s Software Development Lifecycle",
    "section": "Disaster recovery",
    "text": "Disaster recovery\nThe entire history of the Stan C++, CmdStan, RStan, and PyStan repositories is maintained on the GitHub servers as well as on each developer’s individual copy of the repository. Specifically, each repository can be reconstituted from any of the core developers’ machines.\n\n Copyright (2020) Stan Development Team and their assignees. Licensed under CC-BY ND 4.0."
  },
  {
    "objectID": "learn-stan/tutorials.html",
    "href": "learn-stan/tutorials.html",
    "title": "Tutorials",
    "section": "",
    "text": "Tutorials\nTDB - curate tutorials contributed on https://mc-stan.org/workshops and StanCon materials.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "learn-stan/case-studies.html",
    "href": "learn-stan/case-studies.html",
    "title": "Stan Case Studies",
    "section": "",
    "text": "The case studies on this page are intended to reflect best practices in Bayesian methodology and Stan programming. We aim to keep them current with the latest version of the Stan language, but there may be times when case studies need updating to reflect the latest Stan features and syntax.\n\n\n\n\nIn this document, we demonstrate how to implement Bayesian inference for causal effects in randomized experiments with one-sided noncompliance using Stan. Specifically, we aim to replicate the analysis presented in Imbens and Rubin (1997). We present Stan models with and without the exclusion restriction assumption, showcasing a significant advantage of the Bayesian model-based approach.\nView HTML (link opens in new tab)\n\nAuthors\n\nJoonHo Lee, Avi Feller, Sophia Rabe-Hesketh\n\nKeywords\n\ncausal inference, instrumental variables analysis, one-sided compliance, principal stratification\n\nSource Repository\n\nexample-models/education/causal_iv_one-sided (GitHub)\n\nDependencies\n\ntidyverse, rstan, bayesplot, patchwork\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nIn this case study, we fit Bayesian structural equation models (SEM) using Hamiltonian Monte Carlo sampling in Stan-powered R package blavaan and illustrate how to use confirmtory factor analysis and latent growth curve modeling as SEM’s special cases. We also compared the estimates from blavaan with its frequentist counterpart using lavaan.\nView HTML (Link opens in new tab)\n\nAuthors\n\nFeng Ji, Xingyao Xiao, Aybolek Amanmyradova, Sophia Rabe-Hesketh\n\nKeywords\n\nStructural Equation Modeling (SEM), Lavant Variable Modeling, Latent Growth Curve Models, Confirmatory Factor Analysis (CFA), Growth Curve Modeling, Bayesian Model Evaluation\n\nSource Repository\n\nexample-models/education/sem (GitHub)\n\nDependencies\n\nblavaan, lavaan, rstan, MASS, mvtnorm, tidyverse, semPlot, magrittr, lavaan.survey\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\n\n\n\nThis notebook is a short introduction to multilevel regression modeling using the CmdStanPy interface and plotnine, a Python implementation of a grammar of graphics based on ggplot2.\nView (HTML)\n\nAuthors\n\nMitzi Morris\n\nKeywords\n\nPython, CmdStanPy, plotnine, hierarchical/multilevel modeling, linear regression, posterior predictive checks, radon\n\nSource Repository\n\nexample-models/jupyter/radon (GitHub)\n\nDependencies\n\ncmdstanpy, numpy, pandas, matplotlib, plotnine, jupyter\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nIn this case study, we perform image reconstruction in Stan by implementing the HoloML phase retrieval model and then solving the inverse problem with optimization. This case study requires Stan 2.30 or greater in order to use the Fourier transform functions added in that version.\nView (HTML)\n\nAuthors\n\nBrian Ward, Bob Carpenter, and David Barmherzig\n\nKeywords\n\nimage reconstruction, phase retrieval, Fourier transforms, deconvolution\n\nSource Repository\n\nWardBrian/holoml-in-stan (GitHub)\n\nDependencies\n\ncmdstanpy, numpy, matplotlib, scipy, jupyter\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\n\n\n\nIn this case study, we fit the Bayesian latent class model using Hamiltonian Monte Carlo sampling and Variational Bayes in Stan and illustrate the issue of label switching and its treatment with simulated and empirical data.\nView (HTML)\n\nAuthors\n\nFeng Ji, Aybolek Amanmyradova, Sophia Rabe-Hesketh\n\nKeywords\n\nlatent class models, label-switching, post-hoc relabeling, variational Bayes\n\nSource Repository\n\nexample-models/education/latent_class (GitHub)\n\nDependencies\n\nlabel.switching, rstan, magrittr, knitr, poLCA\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\n\n\n\nThe Bayesian model of planetary motion is a simple but powerful example that illustrates important concepts, as well as gaps, in prescribed modeling workflows. Our focus is on Bayesian inference using Markov chains Monte Carlo for a model based on an ordinary differential equations (ODE). Our example presents unexpected multimodality, causing our inference to be unreliable and what is more, dramatically slowing down our ODE integrators. What do we do when our chains do not mix and do not forget their starting points? Reasoning about the computational statistics at hand and the physics of the modeled phenomenon, we diagnose how the modes arise and how to improve our inference. Our process for fitting the model is iterative, starting with a simplification and building the model back up, and makes extensive use of visualization.\nView (HTML)\n\nAuthors\n\nCharles Margossian and Andrew Gelman\n\nKeywords\n\nordinary differential equations, multimodality, classical mechanics\n\nSource Repository\n\nexample-models/knitr/planetary_motion (GitHub)\n\nDependencies\n\nCmdStanR, posterior, ggplot2, dplyr, plyr, tidyr, boot, latex2exp\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nCmdstan 2.24 introduces a new interface for working with Hidden Markov Models (HMMs). This is an example of how to use that interface.\nView (HTML)\n\nAuthors\n\nBen Bales\n\nKeywords\n\nHidden Markov Models, HMMs, cmdstanr, Stan programming\n\nSource Repository\n\nexample-models/knitr/hmm-example (GitHub)\n\nDependencies\n\nCmdStanR, tidyverse, ggplot2, posterior\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nIn this case study, we demonstrate how Stan’s segment function can speed computation on sparse matrices of pairwise neighbors in plant-plant interaction models. In addition, we present solutions to common problems of fitting neighborhood models with hierarchical effects, including a comparison of centered vs. non-centered parameterizations.\nView (HTML)\n\nAuthors\n\nCristina Barber, Andrii Zaiats, Cara Applestein and T.Trevor Caughlin\n\nKeywords\n\nplants, neighbor interactions, sparse matrix, segment function\n\nSource Repository\n\nCristinabarber/Neighbor_Interactions (GitHub)\n\nR Package Dependencies\n\nrstan\n\nLicense\n\nBSD (3 clause), CC BY NC\n\n\n\n\n\nThis gaussian process case study is an extension of the StanCon talk “Failure prediction in hierarchical equipment system: spline fitting naval ship failure”. Many comparison criteria exist, but in terms of prediction accuracy, the gaussian process model outperformed the spline model. However, this accuracy comes at a cost of a more detailed and iterative checking process. This case study shows how identification and underfitting problems diagnosed from pushforward and predictive checks are addressed through reparameterization and adding variables. Basically, our data is highly unbalanced per category with lots of missing data. Also, due to the hierarchical structure of the system, such as shared engine types, the hierarchical model is applicable. For a detailed explanation of the data and spline model, please refer to this notebook.\nView (HTML)\n\nAuthor\n\nHyunji Moon, Jungin Choi\n\nKeywords\n\nHierarchical Gaussian process, Bayesian workflow\n\nSource Repository\n\nexample-models/knitr/gaussian-process (GitHub)\n\nDependencies\n\nCmdStanR, Rstan\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nCmdstan 2.24 introduces a new ODE interface intended to make it easier to specify the ODE system function. This document should serve as an overview of the interface changes as well as a tutorial for converting code written with the old ODE interface.\nView (HTML)\n\nAuthors\n\nBen Bales, Sebastian Weber\n\nKeywords\n\nordinary differential equations, cmdstanr, Stan programming\n\nSource Repository\n\nexample-models/knitr/convert-odes (GitHub)\n\nDependencies\n\nCmdStanR\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nThis tutorial shows how to build, fit, and criticize disease transmission models in Stan, and should be useful to researchers interested in modeling the COVID-19 outbreak and doing Bayesian inference. Bayesian modeling provides a principled way to quantify uncertainty and incorporate prior knowledge into the model. What is more, Stan’s main inference engine, Hamiltonian Monte Carlo sampling, is amiable to diagnostics, which means we can verify whether our inference is reliable. Stan is an expressive probabilistic programing language that abstracts the inference and allows users to focus on the modeling. The resulting code is readable and easily extensible, which makes the modeler’s work more transparent and flexible. In this tutorial, we demonstrate with a simple Susceptible-Infected-Recovered (SIR) model how to formulate, fit, and diagnose a compartmental model in Stan. We also introduce more advanced topics which can help practitioners fit sophisticated models; notably, how to use simulations to probe our model and our priors, and computational techniques to scale ODE-based models.\nView (HTML)\n\nAuthors\n\nLeo Grinsztajn, Elizaveta Semenova, Charles C. Margossian, and Julien Riou\n\nKeywords\n\nDisease transmission, Compartment models, Ordinary Differential Equations, Bayesian Workflow\n\nSource Repository\n\ncharlesm93/disease_transmission_workflow (GitHub)\n\nDependencies\n\nRStan\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nStan 2.23 introduced reduce_sum, a new way to parallelize the execution of a single Stan chain across multiple cores. This introduction copies directly from Richard McElreath’s Multithreading and Map-Reduce in Stan 2.18.0: A Minimal Example\nView (HTML)\n\nAuthor\n\nBen Bales\n\nKeywords\n\nwithin-chain parallel computation, cmdstanr, Stan programming\n\nSource Repository\n\nexample-models/knitr/reduce-sum (GitHub)\n\nDependencies\n\nCmdStanR\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nThis report shows you how to author a Jupyter Notebook for your Stan model and data so that anyone with a modern web browser and a Google account can run your analysis with Google Colaboratory free cloud servers. It shows you how to quickly set up a Stan installation in the cloud and introduces two lightweight interfaces: CmdStanR and CmdStanPy.\nView (HTML)\n\nAuthor\n\nMitzi Morris\n\nKeywords\n\nJupyter, Google Colab, teaching Stan, online classroom, cloud computing\n\nSource Repository\n\nexample-models/knitr/cloud-compute-2020 (GitHub)\n\nDependencies\n\ninternet connection, Google account\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\n\n\n\nIn this document, we discuss the implementation of Bayesian model-based inference for causal effects in Stan. We start by providing an introduction to the Bayesian inferential framework by analyzing a simulated dataset generated under unconfounded treatment assignment. Then we analyze an example dataset obtained from a completely randomized experiment focusing on the specification of the joint distribution of the potential outcomes.\nView (HTML)\n\nAuthor\n\nJoonHo Lee, Avi Feller and Sophia Rabe-Hesketh\n\nKeywords\n\ncausal inference, completely randomized experiments\n\nSource Repository\n\nexample-models/education/causal_rct\n\nR Package Dependencies\n\nrstan, rstanarm, bayesplot, tidyverse, gridExtra, Matching\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nThis case study shows how we can apply Bayesian inference to Hidden Markov Models (HMMs) using Stan to extract useful information from basketball player tracking data. Specifically we show how to tag drive events and how to determine defensive assignment. Before diving into basketball data we show how to fit an HMM in Stan using a simple example. This should help build some intuition for those who are unfamiliar with HMMs and will also show how to specify an HMM using Stan.\nView (HTML)\n\nAuthor\n\nImad Ali\n\nKeywords\n\nhidden markov models, sports\n\nSource Repository\n\nimadmali/bball-hmm (GitHub)\n\nR Package Dependencies\n\nrstan, bayesplot, dplyr\n\nLicense\n\nBSD (3 clause), CC-BY-NC\n\n\n\n\n\nIn this case study, we use Stan to build a series of models to estimate the probability of a successful putt using data from professional golfers. We fit and check the fit of a series of models, demonstrating the benefits of modeling based on substantive (rather than purely statistical) principles. We successfully fit to a small dataset and then have to expand the model to fit a new, larger dataset. We use weakly informative priors and a model-misfit error term to enable the fit.\nView (HTML)\n\nAuthor\n\nAndrew Gelman\n\nKeywords\n\nnonlinear regression, sports\n\nSource Repository\n\nexample-models/knitr/golf (GitHub)\n\nR Package Dependencies\n\nrstan\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nIn this case study, we use Stan to fit the Dyadic Item Response Theory (dIRT) model proposed by (Gin et al. 2019) to measure interactions between pairs of individuals when the responses to items represent the actions/behaviors/perceptions of an individual (called the ‘actor’) made within the context of a dyad formed with another individual (called the ‘partner’). The dIRT model is fit using Stan (version 2.18.1) in R via the rstan package.\nView (HTML)\n\nAuthor\n\nNicholas Sim, Brian Gin, Anders Skrondal and Sophia Rabe-Hesketh\n\nKeywords\n\nitem response theory, social relations model, dyadic data\n\nSource Repository\n\nexample-models/education/dyadic_irt_model (GitHub)\n\nR Package Dependencies\n\nrstan, tidyverse\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\n\n\n\nIn this tutorial, we illustrate how to fit a multilevel linear model within a full Bayesian framework using rstanarm. This tutorial is aimed primarily at educational researchers who have used lme4 in R to fit models to their data and who may be interested in learning how to fit Bayesian multilevel models. However, for readers who have not used lme4 before, we briefly review the use of the package for fitting multilevel models.\nView (HTML)\n\nAuthor\n\nJoonHo Lee, Nicholas Sim, Feng Ji, and Sophia Rabe-Hesketh\n\nKeywords\n\neducation, rstanarm, multilevel models, linear mixed models, hierarchical linear models\n\nSource Repository\n\nexample-models/education/tutorial_rstanarm (GitHub)\n\nR Package Dependencies\n\nrstanarm, mlmRev, ggplot2, lme4\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nLotka (1925) and Volterra (1926) formulated parametric differential equations that characterize the oscillating populations of predators and prey. A statistical model to account for measurement error and unexplained variation uses the deterministic solutions to the Lotka-Volterra equations as expected population sizes. Stan is used to encode the statistical model and perform full Bayesian inference to solve the inverse problem of inferring parameters from noisy data. The model is fit to Canadian lynx and snowshoe hare populations between 1900 and 1920, based on the number of pelts collected annually by the Hudson’s Bay Company. Posterior predictive checks for replicated data show the model fits this data well. Full Bayesian inference may be used to estimate future (or past) populations.\nView (HTML)\n\nAuthor\n\nBob Carpenter\n\nKeywords\n\npopulation dynamics, Lotka-Volterra equations, differential equations, posterior predictive checks\n\nSource Repository\n\nstan-dev/example-models/knitr/lotka-volterra (GitHub)\n\nR Package Dependencies\n\nrstan, &gt;ggplot2, gridExtra, knitr, reshape, tufte\n\nLicense\n\nCode: BSD (3 clause), Text: CC BY-NC 4.0\n\n\n\n\n\nNearest neighbor Gaussian process (NNGP) based models is a family of highly scalable Gaussian processes based models. In brief, NNGP extends the Vecchia’s approximation (Vecchia 1988) to a process using conditional independence given information from neighboring locations. This case study shows how to express and fit these models in Stan.\nView (HTML)\n\nAuthor\n\nLu Zhang\n\nKeywords\n\nGaussian process, nearest neighbor Gaussian process, spatial models, latent process, regression\n\nSource Repository\n\nLuZhangstat/NNGP_STAN (GitHub)\n\nR Package Dependencies\n\nrstan\n\nLicense\n\nCode: BSD (3 clause), Text: CC BY-NC 4.0\n\n\n\n\n\n\n\n\nThis notebook demonstrates how to implement user defined probability functions in Stan language. As an example I use the generalized Pareto distribution (GPD) to model geomagnetic storm data from the World Data Center for Geomagnetism.\nView (HTML)\n\nAuthor\n\nAki Vehtari\n\nKeywords\n\nextreme value analysis, generalized Pareto distribution, user defined probability functions\n\nSource Repository\n\navehtari/BDA_R_demos/demos_rstan/gpareto_functions (GitHub)\n\nR Package Dependencies\n\nrstan, bayesplot, loo, ggplot2, tidyr, dplyr, extraDistr, gridExtra\n\nLicense\n\nCode: BSD (3 clause), Text: CC BY-NC 4.0\n\n\n\n\n\nLoss curves are a standard actuarial technique for helping insurance companies assess the amount of reserve capital they need to keep on hand to cover claims from a line of business. Claims made and reported for a given accounting period are tracked separately over time. This enables the use of historical patterns of claim development to predict expected total claims for newer policies.\nWe model the growth of the losses in each accounting period as an increasing function of time, and use the model to estimate the parameters which determine the shape and form of this growth. We also use the sampler to estimate the values of the “ultimate loss ratio”, i.e. the ratio of the total claims on an accounting period to the total premium received to write those policies. We treat each accounting period as a cohort.\nView (HTML)\n\nAuthor\n\nMick Cooney\n\nKeywords\n\nactuarial science, loss curves, insurance, ultimate loss ratio, hierarchical model\n\nSource Repository\n\nkaybenleroll/stancasestudy_losscurves (GitHub)\n\nR Package Dependencies\n\nrstan, bayesplot, tidyverse, scales, cowplot\n\nLicense\n\nCode: BSD (3 clause), Text: CC BY-NC 4.0\n\n\n\n\n\nIn this document, we discuss the implementation of splines in Stan. We start by providing a brief introduction to splines and then explain how they can be implemented in Stan. We also discuss a novel prior that alleviates some of the practical challenges of spline models.\nView (HTML)\n\nAuthor\n\nMilad Kharratzadeh\n\nKeywords\n\nB-splines, piecewise regression, knots, priors\n\nSource Repository\n\nmilkha/Splines_in_Stan (GitHub)\n\nR Package Dependencies\n\nrstan, splines\n\nLicense\n\nCode: BSD (3 clause), Text: CC BY-NC 4.0\n\n\n\n\n\nThis case study shows how to efficiently encode and compute an Intrinsic Conditional Auto-Regressive (ICAR) model in Stan. When data has a neighborhood structure, ICAR models provide spatial smoothing by averaging measurements of directly adjoining regions. The Besag, York, and Mollié (BYM) model is a Poisson GLM which includes both an ICAR component and an ordinary random-effects component for non-spatial heterogeneity. We compare two variants of the BYM model and fit two datasets taken from epidemiological studies over 56 and 700 regions, respectively.\nView (HTML)\n\nAuthor\n\nMitzi Morris\n\nKeywords\n\nspatial modeling, CAR, ICAR, INLA, OpenBUGS, hierarchical models\n\nSource Repository\n\nstan-dev/example-models (GitHub)\n\nR Package Dependencies\n\ncmdstanr, ggplot2, broom, reshape2, dplyr, maptools, spdep, R-INLA, R2OpenBugs\n\nLicense\n\nCode: BSD (3 clause), Text: CC BY-NC 4.0\n\n\n\n\n\nThis case study reviews the QR decomposition, a technique for decorrelating covariates and, consequently, the resulting posterior distribution in regression models.\nView (HTML)\n\nAuthor\n\nMichael Betancourt\n\nKeywords\n\nMarkov chain Monte Carlo, regression, RStan\n\nSource Repository\n\nbetanalpha/knitr_case_studies/qr_regression (GitHub)\n\nR Package Dependencies\n\nrstan, knitr.\n\nLicense\n\nCode: BSD (3 clause), Text: CC BY-NC 4.0\n\n\n\n\n\nThis case study demonstrates the recommended RStan workflow for ensuring robust inferences with the default dynamic Hamiltonian Monte Carlo algorithm.\nView (HTML)\n\nAuthor\n\nMichael Betancourt\n\nKeywords\n\nMarkov chain Monte Carlo, Hamiltonian Monte Carlo, divergences, RStan\n\nSource Repository\n\nbetanalpha/knitr_case_studies/rstan_workflow (GitHub)\n\nR Package Dependencies\n\nrstan, knitr.\n\nLicense\n\nCode: BSD (3 clause), Text: CC BY-NC 4.0\n\n\n\n\n\nThis case study demonstrates the recommended PyStan workflow for ensuring robust inferences with the default dynamic Hamiltonian Monte Carlo algorithm.\nView (HTML)\n\nAuthor\n\nMichael Betancourt\n\nKeywords\n\nMarkov chain Monte Carlo, Hamiltonian Monte Carlo, divergences, PyStan\n\nSource Repository\n\nbetanalpha/jupyter_case_studies/pystan_workflow (GitHub)\n\nPython Package Dependencies\n\nrstan, pystan, pickle, numpy, md5.\n\nLicense\n\nCode: BSD (3 clause), Text: CC BY-NC 4.0\n\n\n\n\n\nThis case study illustrates the so-called “curse of dimensionality” using simple examples based on simulation to show that all points are far away in high dimensions and that the mode is an atypical draw from a multivariate normal. The information-theoretic concept of typical set is illustrated with both discrete and continuous cases, which show that probability mass is a product of volume and density (or count and mass in the discrete case). It also illustrates Monte Carlo methods and relates distance to the log density of the normal distribution and the chi-squared distribution.\nView R version (HTML)\n\nAuthors\n\nBob Carpenter\n\nKeywords\n\nprobability mass, typical sets, concentration of measure, Monte Carlo methods\n\nSource Repository (R)\n\nstan-dev/example-models/knitr/curse-dims (GitHub)\n\nR Package Dependencies\n\nggplot2\n\nLicense\n\nCode: BSD (3 clause), Text: CC BY-NC 4.0\n\n\nView Python version (HTML)\n\nAuthor (Python translation)\n\nAravind S (Python translation)\n\nSource Repository (Python)\n\nAravinds-ds/Stan-Code/python notebooks/curse_dims (GitHub)\n\nPython Package Dependencies\n\nnumpy, scipy, pandas, matplotlib, collections, sys\n\nLicense\n\nCode: BSD (3 clause), Text: CC BY-NC 4.0\n\n\n\n\n\nThis case study discusses the subtleties of accurate Markov chain Monte Carlo estimation and how divergences can be used to identify biased estimation in practice.\nView (HTML)\n\nAuthor\n\nMichael Betancourt\n\nKeywords\n\nMarkov chain Monte Carlo, Hamiltonian Monte Carlo, divergences, RStan\n\nSource Repository\n\nbetanalpha/knitr_case_studies/divergences_and_bias (GitHub)\n\nR Package Dependencies\n\nrstan, knitr.\n\nLicense\n\nCode: BSD (3 clause), Text: CC BY-NC 4.0\n\n\n\n\n\nThis case study discusses the common pathologies of Bayesian mixture models as well as some strategies for identifying and overcoming them.\nView (HTML)\n\nAuthor\n\nMichael Betancourt\n\nKeywords\n\nMarkov chain Monte Carlo, Hamiltonian Monte Carlo, mixture models, multimodal models, RStan\n\nSource Repository\n\nbetanalpha/knitr_case_studies/identifying_mixture_models (GitHub)\n\nR Package Dependencies\n\nrstan, knitr.\n\nLicense\n\nCode: BSD (3 clause), Text: CC BY-NC 4.0\n\n\n\n\n\nThis case study reviews the basics of weakly-informative priors and how the choice of a specific shape of such a prior affects the resulting posterior distribution.\nView (HTML)\n\nAuthor\n\nMichael Betancourt\n\nKeywords\n\nMarkov chain Monte Carlo, Hamiltonian Monte Carlo, priors, weakly-informative priors, RStan\n\nSource Repository\n\nbetanalpha/knitr_case_studies/weakly_informative_shapes (GitHub)\n\nR Package Dependencies\n\nrstan, knitr.\n\nLicense\n\nCode: BSD (3 clause), Text: CC BY-NC 4.0\n\n\n\n\n\n\n\n\nThis document details sparse exact conditional autoregressive (CAR) models in Stan as an extension of previous work on approximate sparse CAR models in Stan. Sparse representations seem to give order of magnitude efficiency gains, scaling better for large spatial data sets.\nView (HTML)\n\nAuthor\n\nMax Joseph\n\nKeywords\n\nconditional autoregressive (CAR), independent autoregressive (IAR), sparsity, spatial random effects, maps\n\nSource Repository\n\nmbjoseph/CARstan (GitHub)\n\nR Package Dependencies\n\nrstan, dplyr, ggmcmc, knitr, maptools, rgeos, spdep.\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nThis case study replicates the analysis of home radon levels using hierarchical models of Lin, Gelman, Price, and Kurtz (1999). It illustrates how to generalize linear regressions to hierarchical models with group-level predictors and how to compare predictive inferences and evaluate model fits. Along the way it shows how to get data into Stan using pandas, how to sample using PyStan, and how to visualize the results using Seaborn.\nView (HTML)\n\nAuthor\n\nChris Fonnesbeck\n\nKeywords\n\nhierarchical/multilevel modeling, linear regression, model comparison, predictive inference, radon\n\nSource Repository\n\nfonnesbeck/stan_workshop_2016 (GitHub)\n\nPython Package Dependencies\n\npystan, numpy, pandas, matplotlib, seaborn\n\nLicense\n\nApache 2.0 (code), CC-BY 3 (text)\n\n\n\n\n\nWhen changing variables, a Jacobian adjustment needs to be provided to account for the rate of change of the transform. Applying the adjustment ensures that inferences that are based on expectations over the posterior are invariant under reparameterizations. In contrast, the posterior mode changes as a result of the reparameterization. In this note, we use Stan to code a repeated binary trial model parameterized by chance of success, along with its reparameterization in terms of log odds in order to demonstrate the effect of the Jacobian adjustment on the Bayesian posterior and the posterior mode. We contrast the posterior mode to the maximum likelihood estimate, which, like the Bayesian estimates, is invariant under reparameterization. Along the way, we derive the logistic distribution by transforming a uniformly distributed variable.\nView (HTML)\n\nAuthor\n\nBob Carpenter\n\nKeywords\n\nMLE, Bayesian posterior, reparameterization, Jacobian, binomial\n\nSource Repository\n\nexample-models/knitr/mle-params (GitHub)\n\nR Package Dependencies\n\nrstan\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nThis case study documents a Stan model for the two-parameter logistic model (2PL) with hierarchical priors. A brief simulation indicates that the Stan model successfully recovers the generating parameters. An example using a grade 12 science assessment is provided.\nView (HTML)\n\nAuthor\n\nDaniel C. Furr\n\nKeywords\n\neducation, item response theory, two-parameter logistic model, hierarchical priors\n\nSource Repository\n\nexample-models/education/hierarchical_2pl (GitHub)\n\nR Package Dependencies\n\nrstan, ggplot2, mirt\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nThis case study documents a Stan model for the rating scale model (RSM) and the generalized rating scale model (GRSM) with latent regression. The latent regression portion of the models may be restricted to an intercept only, yielding a standard RSM or GRSM. A brief simulation indicates that the Stan models successfully recover the generating parameters. An example using a survey of public perceptions of science and technology is provided.\nView (HTML)\n\nAuthors\n\nDaniel C. Furr\n\nKeywords\n\neducation, item response theory, rating scale model, generalized rating scale model\n\nSource Repository\n\nexample-models/education/rsm_and_grsm (GitHub)\n\nR Package Dependencies\n\nrstan, edstan, ggplot2, ltm\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nThis case study documents a Stan model for the partial credit model (PCM) and the generalized partial credit model (GPCM) with latent regression. The latent regression portion of the models may be restricted to an intercept only, yielding a standard PCM or GPCM. A brief simulation indicates that the Stan models successfully recover the generating parameters. An example using the TIMSS 2011 mathematics assessment is provided\nView (HTML)\n\nAuthors\n\nDaniel C. Furr\n\nKeywords\n\neducation, item response theory, partial credit model, generalized partial credit model\n\nSource Repository\n\nexample-models/education/pcm_and_gpcm (GitHub)\n\nR Package Dependencies\n\nrstan, edstan, ggplot2, TAM\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nThis case study documents Stan models for the Rasch and two-parameter logistic models with latent regression. The latent regression portion of the models may be restricted to an intercept only, yielding standard versions of the models. Simulations indicate that the two models successfully recover generating parameters. An example using a grade 12 science assessment is provided.\nView (HTML)\n\nAuthors\n\nDaniel C. Furr\n\nKeywords\n\neducation, item response theory, rasch model, two-parameter logistic model\n\nSource Repository\n\nexample-models/education/rasch_and_2pl.html (GitHub)\n\nR Package Dependencies\n\nrstan, edstan, ggplot2, TAM\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nThis tutorial introduces the R package edstan for estimating two-parameter logistic item response models using Stan without knowing the Stan language. Subsequently, the tutorial explains how the model can be expressed in the Stan language and fit using the rstan package. Specification of prior distributions and assessment of convergence are discussed. Using the Stan language directly has the advantage that it becomes quite easy to extend the model, and this is demonstrated by adding a latent regression and differential item functioning to the model. Posterior predictive model checking is also demonstrated.\nView (HTML)\n\nAuthor\n\nDaniel C. Furr, Seung Yeon Lee, Joon-Ho Lee, and Sophia Rabe-Hesketh\n\nKeywords\n\neducation, item response theory, two-parameter logistic model\n\nSource Repository\n\nexample-models/education/tutorial_twopl (GitHub)\n\nR Package Dependencies\n\nrstan, reshape2, ggplot2, gridExtra, devtools, edstan\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nThis case study documents a Stan model for the DINA model with independent attributes. A Simulation indicates that the Stan model successfully recovers the generating parameters and predicts respondents’ attribute mastery. A Stan model with no structure of the attributes is also discussed and applied to the simulated data. An example using a subset of the fraction subtraction data is provided.\nView (HTML)\n\nAuthor\n\nSeung Yeon Lee\n\nKeywords\n\neducation, cognitive diagnosis model, diagnostic classification model, attribute mastery, DINA\n\nSource Repository\n\nexample-models/education/dina_independent (GitHub)\n\nR Package Dependencies\n\nrstan, ggplot2, CDM\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nThis note illustrates the effects on posterior inference of pooling data (aka sharing strength) across items for repeated binary trial data. It provides Stan models and R code to fit and check predictive models for three situations: (a) complete pooling, which assumes each item is the same, (b) no pooling, which assumes the items are unrelated, and (c) partial pooling, where the similarity among the items is estimated. We consider two hierarchical models to estimate the partial pooling, one with a beta prior on chance of success and another with a normal prior on the log odds of success. The note explains with working examples how to (i) fit models in RStan and plot the results in R using ggplot2, (ii) estimate event probabilities, (iii) evaluate posterior predictive densities to evaluate model predictions on held-out data, (iv) rank items by chance of success, (v) perform multiple comparisons in several settings, (vi) replicate new data for posterior p-values, and (vii) perform graphical posterior predictive checks.\nView (HTML)\n\nAuthor\n\nBob Carpenter\n\nKeywords\n\nbinary trials, pooling, hierarchical models, baseball, epidemiology, prediction, posterior predictive checks\n\nSource Repository\n\nexample-models/knitr/pool-binary-trials (GitHub)\n\nR Package Dependencies\n\nrstan, ggplot2, rmarkdown\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\nThere is also a version of this case study in which all models are fit using the RStanARM interface. Many of the visualizations are also created using RStanARM’s plotting functions.\nView RStanARM version (HTML)\n\nAuthor\n\nBob Carpenter, Jonah Gabry, Ben Goodrich\n\n\n\n\n\n\n\n\n\nThis case study replicates the analysis and output graphs of Dorazio et al. (2006) noisy-measurement occupancy model for multiple species abundance of butterflies. Going beyond the paper, the supercommunity assumptions are tested to show they are invariant to sizing, and posterior predictive checks are provided.\nView (HTML)\n\nAuthor\n\nBob Carpenter\n\nKeywords\n\necology, occupancy, species abundance, supercommunity, posterior predictive check\n\nSource Repository\n\nexample-models/knitr/dorazio-royle-occupancy (GitHub)\n\nLicense\n\nBSD (3 clause), CC-BY\n\nR Package Dependencies\n\nrstan, ggplot2, rmarkdown\n\n\n\n\n\n\n\n\nThis case study provides ordinary differential equation-based compartment models of soil carbon flux, with experimental data fitted with unknown initial compartment balance and noisy CO2 measurements. Results form Sierra and Müller’s (2014) soilR package are replicated.\nView (HTML)\n\nAuthor\n\nBob Carpenter\n\nKeywords\n\nbiogeochemistry, compartment ODE, soil carbon respiration, incubation experiment\n\nSource Repository\n\nsoil-metamodel/stan/soil-knit (GitHub)\n\nLicense\n\nBSD (3 clause), CC-BY\n\nR Package Dependencies\n\nrstan, ggplot2, rmarkdown\n\n\n\n\n\n\nTo contribute a case study, please contact us through the Stan Forums. We require\n\na documented, reproducible example with narrative documentation (e.g., knitr or Jupyter with software/compiler versions noted and seeds fixed) and\nan open-source code license (preferably BSD or GPL for code, Creative Commons for text); authors retain all copyright."
  },
  {
    "objectID": "learn-stan/case-studies.html#volume-10-2023",
    "href": "learn-stan/case-studies.html#volume-10-2023",
    "title": "Stan Case Studies",
    "section": "",
    "text": "In this document, we demonstrate how to implement Bayesian inference for causal effects in randomized experiments with one-sided noncompliance using Stan. Specifically, we aim to replicate the analysis presented in Imbens and Rubin (1997). We present Stan models with and without the exclusion restriction assumption, showcasing a significant advantage of the Bayesian model-based approach.\nView HTML (link opens in new tab)\n\nAuthors\n\nJoonHo Lee, Avi Feller, Sophia Rabe-Hesketh\n\nKeywords\n\ncausal inference, instrumental variables analysis, one-sided compliance, principal stratification\n\nSource Repository\n\nexample-models/education/causal_iv_one-sided (GitHub)\n\nDependencies\n\ntidyverse, rstan, bayesplot, patchwork\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nIn this case study, we fit Bayesian structural equation models (SEM) using Hamiltonian Monte Carlo sampling in Stan-powered R package blavaan and illustrate how to use confirmtory factor analysis and latent growth curve modeling as SEM’s special cases. We also compared the estimates from blavaan with its frequentist counterpart using lavaan.\nView HTML (Link opens in new tab)\n\nAuthors\n\nFeng Ji, Xingyao Xiao, Aybolek Amanmyradova, Sophia Rabe-Hesketh\n\nKeywords\n\nStructural Equation Modeling (SEM), Lavant Variable Modeling, Latent Growth Curve Models, Confirmatory Factor Analysis (CFA), Growth Curve Modeling, Bayesian Model Evaluation\n\nSource Repository\n\nexample-models/education/sem (GitHub)\n\nDependencies\n\nblavaan, lavaan, rstan, MASS, mvtnorm, tidyverse, semPlot, magrittr, lavaan.survey\n\nLicense\n\nBSD (3 clause), CC-BY"
  },
  {
    "objectID": "learn-stan/case-studies.html#volume-9-2022",
    "href": "learn-stan/case-studies.html#volume-9-2022",
    "title": "Stan Case Studies",
    "section": "",
    "text": "This notebook is a short introduction to multilevel regression modeling using the CmdStanPy interface and plotnine, a Python implementation of a grammar of graphics based on ggplot2.\nView (HTML)\n\nAuthors\n\nMitzi Morris\n\nKeywords\n\nPython, CmdStanPy, plotnine, hierarchical/multilevel modeling, linear regression, posterior predictive checks, radon\n\nSource Repository\n\nexample-models/jupyter/radon (GitHub)\n\nDependencies\n\ncmdstanpy, numpy, pandas, matplotlib, plotnine, jupyter\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nIn this case study, we perform image reconstruction in Stan by implementing the HoloML phase retrieval model and then solving the inverse problem with optimization. This case study requires Stan 2.30 or greater in order to use the Fourier transform functions added in that version.\nView (HTML)\n\nAuthors\n\nBrian Ward, Bob Carpenter, and David Barmherzig\n\nKeywords\n\nimage reconstruction, phase retrieval, Fourier transforms, deconvolution\n\nSource Repository\n\nWardBrian/holoml-in-stan (GitHub)\n\nDependencies\n\ncmdstanpy, numpy, matplotlib, scipy, jupyter\n\nLicense\n\nBSD (3 clause), CC-BY"
  },
  {
    "objectID": "learn-stan/case-studies.html#volume-8-2021",
    "href": "learn-stan/case-studies.html#volume-8-2021",
    "title": "Stan Case Studies",
    "section": "",
    "text": "In this case study, we fit the Bayesian latent class model using Hamiltonian Monte Carlo sampling and Variational Bayes in Stan and illustrate the issue of label switching and its treatment with simulated and empirical data.\nView (HTML)\n\nAuthors\n\nFeng Ji, Aybolek Amanmyradova, Sophia Rabe-Hesketh\n\nKeywords\n\nlatent class models, label-switching, post-hoc relabeling, variational Bayes\n\nSource Repository\n\nexample-models/education/latent_class (GitHub)\n\nDependencies\n\nlabel.switching, rstan, magrittr, knitr, poLCA\n\nLicense\n\nBSD (3 clause), CC-BY"
  },
  {
    "objectID": "learn-stan/case-studies.html#volume-7-2020",
    "href": "learn-stan/case-studies.html#volume-7-2020",
    "title": "Stan Case Studies",
    "section": "",
    "text": "The Bayesian model of planetary motion is a simple but powerful example that illustrates important concepts, as well as gaps, in prescribed modeling workflows. Our focus is on Bayesian inference using Markov chains Monte Carlo for a model based on an ordinary differential equations (ODE). Our example presents unexpected multimodality, causing our inference to be unreliable and what is more, dramatically slowing down our ODE integrators. What do we do when our chains do not mix and do not forget their starting points? Reasoning about the computational statistics at hand and the physics of the modeled phenomenon, we diagnose how the modes arise and how to improve our inference. Our process for fitting the model is iterative, starting with a simplification and building the model back up, and makes extensive use of visualization.\nView (HTML)\n\nAuthors\n\nCharles Margossian and Andrew Gelman\n\nKeywords\n\nordinary differential equations, multimodality, classical mechanics\n\nSource Repository\n\nexample-models/knitr/planetary_motion (GitHub)\n\nDependencies\n\nCmdStanR, posterior, ggplot2, dplyr, plyr, tidyr, boot, latex2exp\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nCmdstan 2.24 introduces a new interface for working with Hidden Markov Models (HMMs). This is an example of how to use that interface.\nView (HTML)\n\nAuthors\n\nBen Bales\n\nKeywords\n\nHidden Markov Models, HMMs, cmdstanr, Stan programming\n\nSource Repository\n\nexample-models/knitr/hmm-example (GitHub)\n\nDependencies\n\nCmdStanR, tidyverse, ggplot2, posterior\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nIn this case study, we demonstrate how Stan’s segment function can speed computation on sparse matrices of pairwise neighbors in plant-plant interaction models. In addition, we present solutions to common problems of fitting neighborhood models with hierarchical effects, including a comparison of centered vs. non-centered parameterizations.\nView (HTML)\n\nAuthors\n\nCristina Barber, Andrii Zaiats, Cara Applestein and T.Trevor Caughlin\n\nKeywords\n\nplants, neighbor interactions, sparse matrix, segment function\n\nSource Repository\n\nCristinabarber/Neighbor_Interactions (GitHub)\n\nR Package Dependencies\n\nrstan\n\nLicense\n\nBSD (3 clause), CC BY NC\n\n\n\n\n\nThis gaussian process case study is an extension of the StanCon talk “Failure prediction in hierarchical equipment system: spline fitting naval ship failure”. Many comparison criteria exist, but in terms of prediction accuracy, the gaussian process model outperformed the spline model. However, this accuracy comes at a cost of a more detailed and iterative checking process. This case study shows how identification and underfitting problems diagnosed from pushforward and predictive checks are addressed through reparameterization and adding variables. Basically, our data is highly unbalanced per category with lots of missing data. Also, due to the hierarchical structure of the system, such as shared engine types, the hierarchical model is applicable. For a detailed explanation of the data and spline model, please refer to this notebook.\nView (HTML)\n\nAuthor\n\nHyunji Moon, Jungin Choi\n\nKeywords\n\nHierarchical Gaussian process, Bayesian workflow\n\nSource Repository\n\nexample-models/knitr/gaussian-process (GitHub)\n\nDependencies\n\nCmdStanR, Rstan\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nCmdstan 2.24 introduces a new ODE interface intended to make it easier to specify the ODE system function. This document should serve as an overview of the interface changes as well as a tutorial for converting code written with the old ODE interface.\nView (HTML)\n\nAuthors\n\nBen Bales, Sebastian Weber\n\nKeywords\n\nordinary differential equations, cmdstanr, Stan programming\n\nSource Repository\n\nexample-models/knitr/convert-odes (GitHub)\n\nDependencies\n\nCmdStanR\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nThis tutorial shows how to build, fit, and criticize disease transmission models in Stan, and should be useful to researchers interested in modeling the COVID-19 outbreak and doing Bayesian inference. Bayesian modeling provides a principled way to quantify uncertainty and incorporate prior knowledge into the model. What is more, Stan’s main inference engine, Hamiltonian Monte Carlo sampling, is amiable to diagnostics, which means we can verify whether our inference is reliable. Stan is an expressive probabilistic programing language that abstracts the inference and allows users to focus on the modeling. The resulting code is readable and easily extensible, which makes the modeler’s work more transparent and flexible. In this tutorial, we demonstrate with a simple Susceptible-Infected-Recovered (SIR) model how to formulate, fit, and diagnose a compartmental model in Stan. We also introduce more advanced topics which can help practitioners fit sophisticated models; notably, how to use simulations to probe our model and our priors, and computational techniques to scale ODE-based models.\nView (HTML)\n\nAuthors\n\nLeo Grinsztajn, Elizaveta Semenova, Charles C. Margossian, and Julien Riou\n\nKeywords\n\nDisease transmission, Compartment models, Ordinary Differential Equations, Bayesian Workflow\n\nSource Repository\n\ncharlesm93/disease_transmission_workflow (GitHub)\n\nDependencies\n\nRStan\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nStan 2.23 introduced reduce_sum, a new way to parallelize the execution of a single Stan chain across multiple cores. This introduction copies directly from Richard McElreath’s Multithreading and Map-Reduce in Stan 2.18.0: A Minimal Example\nView (HTML)\n\nAuthor\n\nBen Bales\n\nKeywords\n\nwithin-chain parallel computation, cmdstanr, Stan programming\n\nSource Repository\n\nexample-models/knitr/reduce-sum (GitHub)\n\nDependencies\n\nCmdStanR\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nThis report shows you how to author a Jupyter Notebook for your Stan model and data so that anyone with a modern web browser and a Google account can run your analysis with Google Colaboratory free cloud servers. It shows you how to quickly set up a Stan installation in the cloud and introduces two lightweight interfaces: CmdStanR and CmdStanPy.\nView (HTML)\n\nAuthor\n\nMitzi Morris\n\nKeywords\n\nJupyter, Google Colab, teaching Stan, online classroom, cloud computing\n\nSource Repository\n\nexample-models/knitr/cloud-compute-2020 (GitHub)\n\nDependencies\n\ninternet connection, Google account\n\nLicense\n\nBSD (3 clause), CC-BY"
  },
  {
    "objectID": "learn-stan/case-studies.html#volume-6-2019",
    "href": "learn-stan/case-studies.html#volume-6-2019",
    "title": "Stan Case Studies",
    "section": "",
    "text": "In this document, we discuss the implementation of Bayesian model-based inference for causal effects in Stan. We start by providing an introduction to the Bayesian inferential framework by analyzing a simulated dataset generated under unconfounded treatment assignment. Then we analyze an example dataset obtained from a completely randomized experiment focusing on the specification of the joint distribution of the potential outcomes.\nView (HTML)\n\nAuthor\n\nJoonHo Lee, Avi Feller and Sophia Rabe-Hesketh\n\nKeywords\n\ncausal inference, completely randomized experiments\n\nSource Repository\n\nexample-models/education/causal_rct\n\nR Package Dependencies\n\nrstan, rstanarm, bayesplot, tidyverse, gridExtra, Matching\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nThis case study shows how we can apply Bayesian inference to Hidden Markov Models (HMMs) using Stan to extract useful information from basketball player tracking data. Specifically we show how to tag drive events and how to determine defensive assignment. Before diving into basketball data we show how to fit an HMM in Stan using a simple example. This should help build some intuition for those who are unfamiliar with HMMs and will also show how to specify an HMM using Stan.\nView (HTML)\n\nAuthor\n\nImad Ali\n\nKeywords\n\nhidden markov models, sports\n\nSource Repository\n\nimadmali/bball-hmm (GitHub)\n\nR Package Dependencies\n\nrstan, bayesplot, dplyr\n\nLicense\n\nBSD (3 clause), CC-BY-NC\n\n\n\n\n\nIn this case study, we use Stan to build a series of models to estimate the probability of a successful putt using data from professional golfers. We fit and check the fit of a series of models, demonstrating the benefits of modeling based on substantive (rather than purely statistical) principles. We successfully fit to a small dataset and then have to expand the model to fit a new, larger dataset. We use weakly informative priors and a model-misfit error term to enable the fit.\nView (HTML)\n\nAuthor\n\nAndrew Gelman\n\nKeywords\n\nnonlinear regression, sports\n\nSource Repository\n\nexample-models/knitr/golf (GitHub)\n\nR Package Dependencies\n\nrstan\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nIn this case study, we use Stan to fit the Dyadic Item Response Theory (dIRT) model proposed by (Gin et al. 2019) to measure interactions between pairs of individuals when the responses to items represent the actions/behaviors/perceptions of an individual (called the ‘actor’) made within the context of a dyad formed with another individual (called the ‘partner’). The dIRT model is fit using Stan (version 2.18.1) in R via the rstan package.\nView (HTML)\n\nAuthor\n\nNicholas Sim, Brian Gin, Anders Skrondal and Sophia Rabe-Hesketh\n\nKeywords\n\nitem response theory, social relations model, dyadic data\n\nSource Repository\n\nexample-models/education/dyadic_irt_model (GitHub)\n\nR Package Dependencies\n\nrstan, tidyverse\n\nLicense\n\nBSD (3 clause), CC-BY"
  },
  {
    "objectID": "learn-stan/case-studies.html#volume-5-2018",
    "href": "learn-stan/case-studies.html#volume-5-2018",
    "title": "Stan Case Studies",
    "section": "",
    "text": "In this tutorial, we illustrate how to fit a multilevel linear model within a full Bayesian framework using rstanarm. This tutorial is aimed primarily at educational researchers who have used lme4 in R to fit models to their data and who may be interested in learning how to fit Bayesian multilevel models. However, for readers who have not used lme4 before, we briefly review the use of the package for fitting multilevel models.\nView (HTML)\n\nAuthor\n\nJoonHo Lee, Nicholas Sim, Feng Ji, and Sophia Rabe-Hesketh\n\nKeywords\n\neducation, rstanarm, multilevel models, linear mixed models, hierarchical linear models\n\nSource Repository\n\nexample-models/education/tutorial_rstanarm (GitHub)\n\nR Package Dependencies\n\nrstanarm, mlmRev, ggplot2, lme4\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nLotka (1925) and Volterra (1926) formulated parametric differential equations that characterize the oscillating populations of predators and prey. A statistical model to account for measurement error and unexplained variation uses the deterministic solutions to the Lotka-Volterra equations as expected population sizes. Stan is used to encode the statistical model and perform full Bayesian inference to solve the inverse problem of inferring parameters from noisy data. The model is fit to Canadian lynx and snowshoe hare populations between 1900 and 1920, based on the number of pelts collected annually by the Hudson’s Bay Company. Posterior predictive checks for replicated data show the model fits this data well. Full Bayesian inference may be used to estimate future (or past) populations.\nView (HTML)\n\nAuthor\n\nBob Carpenter\n\nKeywords\n\npopulation dynamics, Lotka-Volterra equations, differential equations, posterior predictive checks\n\nSource Repository\n\nstan-dev/example-models/knitr/lotka-volterra (GitHub)\n\nR Package Dependencies\n\nrstan, &gt;ggplot2, gridExtra, knitr, reshape, tufte\n\nLicense\n\nCode: BSD (3 clause), Text: CC BY-NC 4.0\n\n\n\n\n\nNearest neighbor Gaussian process (NNGP) based models is a family of highly scalable Gaussian processes based models. In brief, NNGP extends the Vecchia’s approximation (Vecchia 1988) to a process using conditional independence given information from neighboring locations. This case study shows how to express and fit these models in Stan.\nView (HTML)\n\nAuthor\n\nLu Zhang\n\nKeywords\n\nGaussian process, nearest neighbor Gaussian process, spatial models, latent process, regression\n\nSource Repository\n\nLuZhangstat/NNGP_STAN (GitHub)\n\nR Package Dependencies\n\nrstan\n\nLicense\n\nCode: BSD (3 clause), Text: CC BY-NC 4.0"
  },
  {
    "objectID": "learn-stan/case-studies.html#volume-4-2017",
    "href": "learn-stan/case-studies.html#volume-4-2017",
    "title": "Stan Case Studies",
    "section": "",
    "text": "This notebook demonstrates how to implement user defined probability functions in Stan language. As an example I use the generalized Pareto distribution (GPD) to model geomagnetic storm data from the World Data Center for Geomagnetism.\nView (HTML)\n\nAuthor\n\nAki Vehtari\n\nKeywords\n\nextreme value analysis, generalized Pareto distribution, user defined probability functions\n\nSource Repository\n\navehtari/BDA_R_demos/demos_rstan/gpareto_functions (GitHub)\n\nR Package Dependencies\n\nrstan, bayesplot, loo, ggplot2, tidyr, dplyr, extraDistr, gridExtra\n\nLicense\n\nCode: BSD (3 clause), Text: CC BY-NC 4.0\n\n\n\n\n\nLoss curves are a standard actuarial technique for helping insurance companies assess the amount of reserve capital they need to keep on hand to cover claims from a line of business. Claims made and reported for a given accounting period are tracked separately over time. This enables the use of historical patterns of claim development to predict expected total claims for newer policies.\nWe model the growth of the losses in each accounting period as an increasing function of time, and use the model to estimate the parameters which determine the shape and form of this growth. We also use the sampler to estimate the values of the “ultimate loss ratio”, i.e. the ratio of the total claims on an accounting period to the total premium received to write those policies. We treat each accounting period as a cohort.\nView (HTML)\n\nAuthor\n\nMick Cooney\n\nKeywords\n\nactuarial science, loss curves, insurance, ultimate loss ratio, hierarchical model\n\nSource Repository\n\nkaybenleroll/stancasestudy_losscurves (GitHub)\n\nR Package Dependencies\n\nrstan, bayesplot, tidyverse, scales, cowplot\n\nLicense\n\nCode: BSD (3 clause), Text: CC BY-NC 4.0\n\n\n\n\n\nIn this document, we discuss the implementation of splines in Stan. We start by providing a brief introduction to splines and then explain how they can be implemented in Stan. We also discuss a novel prior that alleviates some of the practical challenges of spline models.\nView (HTML)\n\nAuthor\n\nMilad Kharratzadeh\n\nKeywords\n\nB-splines, piecewise regression, knots, priors\n\nSource Repository\n\nmilkha/Splines_in_Stan (GitHub)\n\nR Package Dependencies\n\nrstan, splines\n\nLicense\n\nCode: BSD (3 clause), Text: CC BY-NC 4.0\n\n\n\n\n\nThis case study shows how to efficiently encode and compute an Intrinsic Conditional Auto-Regressive (ICAR) model in Stan. When data has a neighborhood structure, ICAR models provide spatial smoothing by averaging measurements of directly adjoining regions. The Besag, York, and Mollié (BYM) model is a Poisson GLM which includes both an ICAR component and an ordinary random-effects component for non-spatial heterogeneity. We compare two variants of the BYM model and fit two datasets taken from epidemiological studies over 56 and 700 regions, respectively.\nView (HTML)\n\nAuthor\n\nMitzi Morris\n\nKeywords\n\nspatial modeling, CAR, ICAR, INLA, OpenBUGS, hierarchical models\n\nSource Repository\n\nstan-dev/example-models (GitHub)\n\nR Package Dependencies\n\ncmdstanr, ggplot2, broom, reshape2, dplyr, maptools, spdep, R-INLA, R2OpenBugs\n\nLicense\n\nCode: BSD (3 clause), Text: CC BY-NC 4.0\n\n\n\n\n\nThis case study reviews the QR decomposition, a technique for decorrelating covariates and, consequently, the resulting posterior distribution in regression models.\nView (HTML)\n\nAuthor\n\nMichael Betancourt\n\nKeywords\n\nMarkov chain Monte Carlo, regression, RStan\n\nSource Repository\n\nbetanalpha/knitr_case_studies/qr_regression (GitHub)\n\nR Package Dependencies\n\nrstan, knitr.\n\nLicense\n\nCode: BSD (3 clause), Text: CC BY-NC 4.0\n\n\n\n\n\nThis case study demonstrates the recommended RStan workflow for ensuring robust inferences with the default dynamic Hamiltonian Monte Carlo algorithm.\nView (HTML)\n\nAuthor\n\nMichael Betancourt\n\nKeywords\n\nMarkov chain Monte Carlo, Hamiltonian Monte Carlo, divergences, RStan\n\nSource Repository\n\nbetanalpha/knitr_case_studies/rstan_workflow (GitHub)\n\nR Package Dependencies\n\nrstan, knitr.\n\nLicense\n\nCode: BSD (3 clause), Text: CC BY-NC 4.0\n\n\n\n\n\nThis case study demonstrates the recommended PyStan workflow for ensuring robust inferences with the default dynamic Hamiltonian Monte Carlo algorithm.\nView (HTML)\n\nAuthor\n\nMichael Betancourt\n\nKeywords\n\nMarkov chain Monte Carlo, Hamiltonian Monte Carlo, divergences, PyStan\n\nSource Repository\n\nbetanalpha/jupyter_case_studies/pystan_workflow (GitHub)\n\nPython Package Dependencies\n\nrstan, pystan, pickle, numpy, md5.\n\nLicense\n\nCode: BSD (3 clause), Text: CC BY-NC 4.0\n\n\n\n\n\nThis case study illustrates the so-called “curse of dimensionality” using simple examples based on simulation to show that all points are far away in high dimensions and that the mode is an atypical draw from a multivariate normal. The information-theoretic concept of typical set is illustrated with both discrete and continuous cases, which show that probability mass is a product of volume and density (or count and mass in the discrete case). It also illustrates Monte Carlo methods and relates distance to the log density of the normal distribution and the chi-squared distribution.\nView R version (HTML)\n\nAuthors\n\nBob Carpenter\n\nKeywords\n\nprobability mass, typical sets, concentration of measure, Monte Carlo methods\n\nSource Repository (R)\n\nstan-dev/example-models/knitr/curse-dims (GitHub)\n\nR Package Dependencies\n\nggplot2\n\nLicense\n\nCode: BSD (3 clause), Text: CC BY-NC 4.0\n\n\nView Python version (HTML)\n\nAuthor (Python translation)\n\nAravind S (Python translation)\n\nSource Repository (Python)\n\nAravinds-ds/Stan-Code/python notebooks/curse_dims (GitHub)\n\nPython Package Dependencies\n\nnumpy, scipy, pandas, matplotlib, collections, sys\n\nLicense\n\nCode: BSD (3 clause), Text: CC BY-NC 4.0\n\n\n\n\n\nThis case study discusses the subtleties of accurate Markov chain Monte Carlo estimation and how divergences can be used to identify biased estimation in practice.\nView (HTML)\n\nAuthor\n\nMichael Betancourt\n\nKeywords\n\nMarkov chain Monte Carlo, Hamiltonian Monte Carlo, divergences, RStan\n\nSource Repository\n\nbetanalpha/knitr_case_studies/divergences_and_bias (GitHub)\n\nR Package Dependencies\n\nrstan, knitr.\n\nLicense\n\nCode: BSD (3 clause), Text: CC BY-NC 4.0\n\n\n\n\n\nThis case study discusses the common pathologies of Bayesian mixture models as well as some strategies for identifying and overcoming them.\nView (HTML)\n\nAuthor\n\nMichael Betancourt\n\nKeywords\n\nMarkov chain Monte Carlo, Hamiltonian Monte Carlo, mixture models, multimodal models, RStan\n\nSource Repository\n\nbetanalpha/knitr_case_studies/identifying_mixture_models (GitHub)\n\nR Package Dependencies\n\nrstan, knitr.\n\nLicense\n\nCode: BSD (3 clause), Text: CC BY-NC 4.0\n\n\n\n\n\nThis case study reviews the basics of weakly-informative priors and how the choice of a specific shape of such a prior affects the resulting posterior distribution.\nView (HTML)\n\nAuthor\n\nMichael Betancourt\n\nKeywords\n\nMarkov chain Monte Carlo, Hamiltonian Monte Carlo, priors, weakly-informative priors, RStan\n\nSource Repository\n\nbetanalpha/knitr_case_studies/weakly_informative_shapes (GitHub)\n\nR Package Dependencies\n\nrstan, knitr.\n\nLicense\n\nCode: BSD (3 clause), Text: CC BY-NC 4.0"
  },
  {
    "objectID": "learn-stan/case-studies.html#volume-3-2016",
    "href": "learn-stan/case-studies.html#volume-3-2016",
    "title": "Stan Case Studies",
    "section": "",
    "text": "This document details sparse exact conditional autoregressive (CAR) models in Stan as an extension of previous work on approximate sparse CAR models in Stan. Sparse representations seem to give order of magnitude efficiency gains, scaling better for large spatial data sets.\nView (HTML)\n\nAuthor\n\nMax Joseph\n\nKeywords\n\nconditional autoregressive (CAR), independent autoregressive (IAR), sparsity, spatial random effects, maps\n\nSource Repository\n\nmbjoseph/CARstan (GitHub)\n\nR Package Dependencies\n\nrstan, dplyr, ggmcmc, knitr, maptools, rgeos, spdep.\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nThis case study replicates the analysis of home radon levels using hierarchical models of Lin, Gelman, Price, and Kurtz (1999). It illustrates how to generalize linear regressions to hierarchical models with group-level predictors and how to compare predictive inferences and evaluate model fits. Along the way it shows how to get data into Stan using pandas, how to sample using PyStan, and how to visualize the results using Seaborn.\nView (HTML)\n\nAuthor\n\nChris Fonnesbeck\n\nKeywords\n\nhierarchical/multilevel modeling, linear regression, model comparison, predictive inference, radon\n\nSource Repository\n\nfonnesbeck/stan_workshop_2016 (GitHub)\n\nPython Package Dependencies\n\npystan, numpy, pandas, matplotlib, seaborn\n\nLicense\n\nApache 2.0 (code), CC-BY 3 (text)\n\n\n\n\n\nWhen changing variables, a Jacobian adjustment needs to be provided to account for the rate of change of the transform. Applying the adjustment ensures that inferences that are based on expectations over the posterior are invariant under reparameterizations. In contrast, the posterior mode changes as a result of the reparameterization. In this note, we use Stan to code a repeated binary trial model parameterized by chance of success, along with its reparameterization in terms of log odds in order to demonstrate the effect of the Jacobian adjustment on the Bayesian posterior and the posterior mode. We contrast the posterior mode to the maximum likelihood estimate, which, like the Bayesian estimates, is invariant under reparameterization. Along the way, we derive the logistic distribution by transforming a uniformly distributed variable.\nView (HTML)\n\nAuthor\n\nBob Carpenter\n\nKeywords\n\nMLE, Bayesian posterior, reparameterization, Jacobian, binomial\n\nSource Repository\n\nexample-models/knitr/mle-params (GitHub)\n\nR Package Dependencies\n\nrstan\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nThis case study documents a Stan model for the two-parameter logistic model (2PL) with hierarchical priors. A brief simulation indicates that the Stan model successfully recovers the generating parameters. An example using a grade 12 science assessment is provided.\nView (HTML)\n\nAuthor\n\nDaniel C. Furr\n\nKeywords\n\neducation, item response theory, two-parameter logistic model, hierarchical priors\n\nSource Repository\n\nexample-models/education/hierarchical_2pl (GitHub)\n\nR Package Dependencies\n\nrstan, ggplot2, mirt\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nThis case study documents a Stan model for the rating scale model (RSM) and the generalized rating scale model (GRSM) with latent regression. The latent regression portion of the models may be restricted to an intercept only, yielding a standard RSM or GRSM. A brief simulation indicates that the Stan models successfully recover the generating parameters. An example using a survey of public perceptions of science and technology is provided.\nView (HTML)\n\nAuthors\n\nDaniel C. Furr\n\nKeywords\n\neducation, item response theory, rating scale model, generalized rating scale model\n\nSource Repository\n\nexample-models/education/rsm_and_grsm (GitHub)\n\nR Package Dependencies\n\nrstan, edstan, ggplot2, ltm\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nThis case study documents a Stan model for the partial credit model (PCM) and the generalized partial credit model (GPCM) with latent regression. The latent regression portion of the models may be restricted to an intercept only, yielding a standard PCM or GPCM. A brief simulation indicates that the Stan models successfully recover the generating parameters. An example using the TIMSS 2011 mathematics assessment is provided\nView (HTML)\n\nAuthors\n\nDaniel C. Furr\n\nKeywords\n\neducation, item response theory, partial credit model, generalized partial credit model\n\nSource Repository\n\nexample-models/education/pcm_and_gpcm (GitHub)\n\nR Package Dependencies\n\nrstan, edstan, ggplot2, TAM\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nThis case study documents Stan models for the Rasch and two-parameter logistic models with latent regression. The latent regression portion of the models may be restricted to an intercept only, yielding standard versions of the models. Simulations indicate that the two models successfully recover generating parameters. An example using a grade 12 science assessment is provided.\nView (HTML)\n\nAuthors\n\nDaniel C. Furr\n\nKeywords\n\neducation, item response theory, rasch model, two-parameter logistic model\n\nSource Repository\n\nexample-models/education/rasch_and_2pl.html (GitHub)\n\nR Package Dependencies\n\nrstan, edstan, ggplot2, TAM\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nThis tutorial introduces the R package edstan for estimating two-parameter logistic item response models using Stan without knowing the Stan language. Subsequently, the tutorial explains how the model can be expressed in the Stan language and fit using the rstan package. Specification of prior distributions and assessment of convergence are discussed. Using the Stan language directly has the advantage that it becomes quite easy to extend the model, and this is demonstrated by adding a latent regression and differential item functioning to the model. Posterior predictive model checking is also demonstrated.\nView (HTML)\n\nAuthor\n\nDaniel C. Furr, Seung Yeon Lee, Joon-Ho Lee, and Sophia Rabe-Hesketh\n\nKeywords\n\neducation, item response theory, two-parameter logistic model\n\nSource Repository\n\nexample-models/education/tutorial_twopl (GitHub)\n\nR Package Dependencies\n\nrstan, reshape2, ggplot2, gridExtra, devtools, edstan\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nThis case study documents a Stan model for the DINA model with independent attributes. A Simulation indicates that the Stan model successfully recovers the generating parameters and predicts respondents’ attribute mastery. A Stan model with no structure of the attributes is also discussed and applied to the simulated data. An example using a subset of the fraction subtraction data is provided.\nView (HTML)\n\nAuthor\n\nSeung Yeon Lee\n\nKeywords\n\neducation, cognitive diagnosis model, diagnostic classification model, attribute mastery, DINA\n\nSource Repository\n\nexample-models/education/dina_independent (GitHub)\n\nR Package Dependencies\n\nrstan, ggplot2, CDM\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\n\nThis note illustrates the effects on posterior inference of pooling data (aka sharing strength) across items for repeated binary trial data. It provides Stan models and R code to fit and check predictive models for three situations: (a) complete pooling, which assumes each item is the same, (b) no pooling, which assumes the items are unrelated, and (c) partial pooling, where the similarity among the items is estimated. We consider two hierarchical models to estimate the partial pooling, one with a beta prior on chance of success and another with a normal prior on the log odds of success. The note explains with working examples how to (i) fit models in RStan and plot the results in R using ggplot2, (ii) estimate event probabilities, (iii) evaluate posterior predictive densities to evaluate model predictions on held-out data, (iv) rank items by chance of success, (v) perform multiple comparisons in several settings, (vi) replicate new data for posterior p-values, and (vii) perform graphical posterior predictive checks.\nView (HTML)\n\nAuthor\n\nBob Carpenter\n\nKeywords\n\nbinary trials, pooling, hierarchical models, baseball, epidemiology, prediction, posterior predictive checks\n\nSource Repository\n\nexample-models/knitr/pool-binary-trials (GitHub)\n\nR Package Dependencies\n\nrstan, ggplot2, rmarkdown\n\nLicense\n\nBSD (3 clause), CC-BY\n\n\n\n\nThere is also a version of this case study in which all models are fit using the RStanARM interface. Many of the visualizations are also created using RStanARM’s plotting functions.\nView RStanARM version (HTML)\n\nAuthor\n\nBob Carpenter, Jonah Gabry, Ben Goodrich"
  },
  {
    "objectID": "learn-stan/case-studies.html#volume-2-2015",
    "href": "learn-stan/case-studies.html#volume-2-2015",
    "title": "Stan Case Studies",
    "section": "",
    "text": "This case study replicates the analysis and output graphs of Dorazio et al. (2006) noisy-measurement occupancy model for multiple species abundance of butterflies. Going beyond the paper, the supercommunity assumptions are tested to show they are invariant to sizing, and posterior predictive checks are provided.\nView (HTML)\n\nAuthor\n\nBob Carpenter\n\nKeywords\n\necology, occupancy, species abundance, supercommunity, posterior predictive check\n\nSource Repository\n\nexample-models/knitr/dorazio-royle-occupancy (GitHub)\n\nLicense\n\nBSD (3 clause), CC-BY\n\nR Package Dependencies\n\nrstan, ggplot2, rmarkdown"
  },
  {
    "objectID": "learn-stan/case-studies.html#volume-1-2014",
    "href": "learn-stan/case-studies.html#volume-1-2014",
    "title": "Stan Case Studies",
    "section": "",
    "text": "This case study provides ordinary differential equation-based compartment models of soil carbon flux, with experimental data fitted with unknown initial compartment balance and noisy CO2 measurements. Results form Sierra and Müller’s (2014) soilR package are replicated.\nView (HTML)\n\nAuthor\n\nBob Carpenter\n\nKeywords\n\nbiogeochemistry, compartment ODE, soil carbon respiration, incubation experiment\n\nSource Repository\n\nsoil-metamodel/stan/soil-knit (GitHub)\n\nLicense\n\nBSD (3 clause), CC-BY\n\nR Package Dependencies\n\nrstan, ggplot2, rmarkdown"
  },
  {
    "objectID": "learn-stan/case-studies.html#contributing-case-studies",
    "href": "learn-stan/case-studies.html#contributing-case-studies",
    "title": "Stan Case Studies",
    "section": "",
    "text": "To contribute a case study, please contact us through the Stan Forums. We require\n\na documented, reproducible example with narrative documentation (e.g., knitr or Jupyter with software/compiler versions noted and seeds fixed) and\nan open-source code license (preferably BSD or GPL for code, Creative Commons for text); authors retain all copyright."
  },
  {
    "objectID": "tools/tools.html",
    "href": "tools/tools.html",
    "title": "Stan Interfaces and Tools",
    "section": "",
    "text": "Language\n\n\n\n\n\n\nStan Interfaces\n\n\n\n\nWrite, compile, and run new Stan models\n\n\n\n\n\n\nJulia\n\n\nStan.jl\n\n\n\n\n\n\nPython\n\n\nCmdStanPy*, PyStan\n\n\n\n\n\n\nR\n\n\nCmdStanR*, RStan\n\n\n\n\n\n\n\n\n*Note: CmdStanPy and CmdStanR are recommended for new users;PyStan and RStan continue to be supported.\n\n\n\n\n\n\nshell\n\n\nCmdStan\n\n\n\n\nHigh-level Interfaces\n\n\n\n\nUse existing Stan models\n\n\n\n\n\n\nR\n\n\nBRMS Specify and fit multivariate and multilevel models in Stan using extended R-formula syntax.\n\n\n\n\n\n\nR\n\n\nRStanArm Pre-compiled Stan versions of existing R model functions.\n\n\n\n\nPosterior Analysis Tools\n\n\n\n\nValidate, visualize, and compare fitted models\n\n\n\n\n\n\nJulia\n\n\nArviZ.jl\n\n\n\n\n\n\nPython\n\n\nArviZ\n\n\n\n\n\n\nR\n\n\nBayesplot - plot model outputs, loo - leave-one-out cross validation posterior - get model estimates, projpred - check model predictions\n\n\n\n\n\n\nWeb browser\n\n\nMCMC Monitor\n\n\n\n\nFor Algorithm Developers\n\n\n\n\nAccess Stan model methods from higher-level languages\n\n\n\n\n\n\nJulia, Python, R, Rust\n\n\nBridgeStan Library with bindings to a model’s log densities, gradients, Hessians, and constraining and unconstraining transforms.\n\n\n\n\nFor Package Developers\n\n\n\n\nBuild tools that use Stan\n\n\n\n\n\n\nC++\n\n\nstan-dev/math\n\n\n\n\n\n\nR\n\n\nrstantools\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "install/install.html",
    "href": "install/install.html",
    "title": "Stan",
    "section": "",
    "text": "Stan is available for all major operating systems and has packages in several popular languages. Most users can get started by just selecting their preferred options in the grid below. If you don’t see your exact set-up, see Other packages and environments below for more programming language options and ways of using Stan.\n\n\n\n\n\n\nPrerequisites\n\n\n\nStan requires a C++17 compiler and some additional tools for building. The conda option of certain packages can install these for you, or we recommend RTools TODO\n\n\nStan requires a C++17 compiler. The conda option of certain packages can install this for you, or we recommend to install Xcode from the App Store and then run xcode-select --install.\n\n\nStan requires a C++17 compiler. The conda option of certain packages can install this for you, or on .deb based distros, sudo apt-get install build-essential will install what you need.\n\n\n\n\n\nHow to Install\n\n\n\nPlease select interface and preferred package manager.\n\n\n\nRun pip install cmdstanpy. Then, in Python, run import cmdstanpy; cmdstanpy.install_cmdstan() or follow the manual installation instructions for CmdStan.\nFor more information, see the CmdStanPy documentation.\n\n\nRun conda install -c conda-forge cmdstanpy.\nNote: this will also install CmdStan and any system prerequesites.\n\n\nRun pip install -e git+https://github.com/stan-dev/cmdstanpy@develop#egg=cmdstanpy. Then, in Python, run import cmdstanpy; cmdstanpy.install_cmdstan() or follow the manual installation instructions for CmdStan.\nFor more information, see the CmdStanPy documentation.\n\n\n\nIn R, run install.packages(\"cmdstanr\", repos = c('https://stan-dev.r-universe.dev', getOption(\"repos\"))). Then run cmdstanr::install_cmdstan() or follow the manual installation instructions for CmdStan.\nFor more information, see the CmdStanR documentation\n\n\nRun conda install -c conda-forge r-cmdstanr.\nNote: this will also install CmdStan and any system prerequesites.\n\n\nIn R, run remotes::install_github(\"stan-dev/cmdstanr\"). Then run cmdstanr::install_cmdstan() or follow the manual installation instructions for CmdStan.\nFor more information, see the CmdStanR documentation\n\n\n\nTODO 1\n\n\nTODO 2\n\n\nTODO 3\n\n\n\nTODO 4\n\n\nTODO 5\n\n\nTODO 6\n\n\n\nTODO 7\n\n\nTODO 8\n\n\nRun conda install -c conda-forge r-rstan.\nNote: this will also install any system prerequesites.\n\n\nTODO 9\n\n\n\nTODO 10\n\n\nTODO 11"
  },
  {
    "objectID": "install/install.html#download-and-install-stan",
    "href": "install/install.html#download-and-install-stan",
    "title": "Stan",
    "section": "",
    "text": "Stan is available for all major operating systems and has packages in several popular languages. Most users can get started by just selecting their preferred options in the grid below. If you don’t see your exact set-up, see Other packages and environments below for more programming language options and ways of using Stan.\n\n\n\n\n\n\nPrerequisites\n\n\n\nStan requires a C++17 compiler and some additional tools for building. The conda option of certain packages can install these for you, or we recommend RTools TODO\n\n\nStan requires a C++17 compiler. The conda option of certain packages can install this for you, or we recommend to install Xcode from the App Store and then run xcode-select --install.\n\n\nStan requires a C++17 compiler. The conda option of certain packages can install this for you, or on .deb based distros, sudo apt-get install build-essential will install what you need.\n\n\n\n\n\nHow to Install\n\n\n\nPlease select interface and preferred package manager.\n\n\n\nRun pip install cmdstanpy. Then, in Python, run import cmdstanpy; cmdstanpy.install_cmdstan() or follow the manual installation instructions for CmdStan.\nFor more information, see the CmdStanPy documentation.\n\n\nRun conda install -c conda-forge cmdstanpy.\nNote: this will also install CmdStan and any system prerequesites.\n\n\nRun pip install -e git+https://github.com/stan-dev/cmdstanpy@develop#egg=cmdstanpy. Then, in Python, run import cmdstanpy; cmdstanpy.install_cmdstan() or follow the manual installation instructions for CmdStan.\nFor more information, see the CmdStanPy documentation.\n\n\n\nIn R, run install.packages(\"cmdstanr\", repos = c('https://stan-dev.r-universe.dev', getOption(\"repos\"))). Then run cmdstanr::install_cmdstan() or follow the manual installation instructions for CmdStan.\nFor more information, see the CmdStanR documentation\n\n\nRun conda install -c conda-forge r-cmdstanr.\nNote: this will also install CmdStan and any system prerequesites.\n\n\nIn R, run remotes::install_github(\"stan-dev/cmdstanr\"). Then run cmdstanr::install_cmdstan() or follow the manual installation instructions for CmdStan.\nFor more information, see the CmdStanR documentation\n\n\n\nTODO 1\n\n\nTODO 2\n\n\nTODO 3\n\n\n\nTODO 4\n\n\nTODO 5\n\n\nTODO 6\n\n\n\nTODO 7\n\n\nTODO 8\n\n\nRun conda install -c conda-forge r-rstan.\nNote: this will also install any system prerequesites.\n\n\nTODO 9\n\n\n\nTODO 10\n\n\nTODO 11"
  },
  {
    "objectID": "install/install.html#in-depth-instructions",
    "href": "install/install.html#in-depth-instructions",
    "title": "Stan",
    "section": "In-Depth Instructions",
    "text": "In-Depth Instructions\n\nPlatform\n\nLinux\n\nwhich C++\n\n\n\nMacOS\n\nXcode\n\n\n\nWindows\n\nConda\nRTools"
  },
  {
    "objectID": "install/install.html#other-packages",
    "href": "install/install.html#other-packages",
    "title": "Stan",
    "section": "Other packages and environments",
    "text": "Other packages and environments\n\nGoogle Colab\n\n\nMathematica, Stata, etc?"
  },
  {
    "objectID": "install/install.html#troubleshooting",
    "href": "install/install.html#troubleshooting",
    "title": "Stan",
    "section": "Troubleshooting",
    "text": "Troubleshooting\n\nC++ Versions\n\n\nC++ Libraries\n\nBoost\nSundials\nTBB\n\n\n\nGPU Support"
  },
  {
    "objectID": "learn-stan/articles.html",
    "href": "learn-stan/articles.html",
    "title": "Stan",
    "section": "",
    "text": "Bob Carpenter, Andrew Gelman, Matthew D. Hoffman, Daniel Lee, Ben Goodrich, Michael Betancourt, Marcus Brubaker, Jiqiang Guo, Peter Li, and Allen Riddell. 2017. Stan: A probabilistic programming language. Journal of Statistical Software 76(1). 10.18637/jss.v076.i01\nAki Vehtari, Andrew Gelman, and Jonah Gabry. 2016. Practical Bayesian model evaluation using leave-one-out cross-validation and WAIC. Statistics and Computing. doi:10.1007/s11222-016-9696-4.\nRobert L. Grant, Daniel C. Furr, Bob Carpenter, and Andrew Gelman. 2016. Fitting Bayesian item response models in Stata and Stan. arXiv 1601.03443.\nAndrew Gelman, Daniel Lee, and Jiqiang Guo. 2015. Stan: A probabilistic programming language for Bayesian inference and optimization. Journal of Education and Behavioral Statistics. 40(5):530–543.\nAlp Kucukelbir, Rajesh Ranganath, Andrew Gelman and David M. Blei. 2015. Automatic Variational Inference in Stan, NIPS.\nBob Carpenter, Matthew D. Hoffman, Marcus Brubaker, Daniel Lee, Peter Li, and Michael J. Betancourt. 2015. The Stan Math Library: Reverse-Mode Automatic Differentiation in C++. arXiv 1509.07164."
  },
  {
    "objectID": "learn-stan/articles.html#stan-language-and-algorithms",
    "href": "learn-stan/articles.html#stan-language-and-algorithms",
    "title": "Stan",
    "section": "",
    "text": "Bob Carpenter, Andrew Gelman, Matthew D. Hoffman, Daniel Lee, Ben Goodrich, Michael Betancourt, Marcus Brubaker, Jiqiang Guo, Peter Li, and Allen Riddell. 2017. Stan: A probabilistic programming language. Journal of Statistical Software 76(1). 10.18637/jss.v076.i01\nAki Vehtari, Andrew Gelman, and Jonah Gabry. 2016. Practical Bayesian model evaluation using leave-one-out cross-validation and WAIC. Statistics and Computing. doi:10.1007/s11222-016-9696-4.\nRobert L. Grant, Daniel C. Furr, Bob Carpenter, and Andrew Gelman. 2016. Fitting Bayesian item response models in Stata and Stan. arXiv 1601.03443.\nAndrew Gelman, Daniel Lee, and Jiqiang Guo. 2015. Stan: A probabilistic programming language for Bayesian inference and optimization. Journal of Education and Behavioral Statistics. 40(5):530–543.\nAlp Kucukelbir, Rajesh Ranganath, Andrew Gelman and David M. Blei. 2015. Automatic Variational Inference in Stan, NIPS.\nBob Carpenter, Matthew D. Hoffman, Marcus Brubaker, Daniel Lee, Peter Li, and Michael J. Betancourt. 2015. The Stan Math Library: Reverse-Mode Automatic Differentiation in C++. arXiv 1509.07164."
  },
  {
    "objectID": "learn-stan/articles.html#hamiltonian-monte-carlo",
    "href": "learn-stan/articles.html#hamiltonian-monte-carlo",
    "title": "Stan",
    "section": "Hamiltonian Monte Carlo",
    "text": "Hamiltonian Monte Carlo\n\nMichael Betancourt. 2017. A Conceptual Introduction to Hamiltonian Monte Carlo. arXiv:1701.02434.\nCole C. Monnahan, James T. Thorson, and Trevor A. Branch. 2016. Faster estimation of Bayesian models in ecology using Hamiltonian Monte Carlo. Methods in Ecology and Evolution.\nMichael J. Betancourt. 2016. Identifying the Optimal Integration Time in Hamiltonian Monte Carlo. arXiv:1601.00225.\nMatthew D. Hoffman and Andrew Gelman. 2014. The No-U-Turn Sampler: Adaptively Setting Path Lengths in Hamiltonian Monte Carlo. Journal of Machine Learning Research. 15(Apr):1593–1623.\nMichael J. Betancourt, Mark Girolami. 2013. Hamiltonian Monte Carlo for Hierarchical Models. arXiv 1312.0906.\nMichael J. Betancourt. 2013. A General Metric for Riemannian Manifold Hamiltonian Monte Carlo. arXiv 1212.4693.\nMichael J. Betancourt. 2013. Generalizing the No-U-Turn Sampler to Riemannian Manifolds. arXiv 1304.1920.\nRadford Neal. 2011. http://www.mcmchandbook.net/HandbookChapter5.pdf. In Handbook of Markov Chain Monte Carlo, edited by Steve Brooks, Andrew Gelman, Galin L. Jones, and Xiao-Li Meng. Chapman-Hall/CRC."
  },
  {
    "objectID": "learn-stan/articles.html#variational-methods",
    "href": "learn-stan/articles.html#variational-methods",
    "title": "Stan",
    "section": "Variational Methods",
    "text": "Variational Methods\n\nPathfinder\nADVI"
  },
  {
    "objectID": "learn-stan/articles.html#bayesian-workflow",
    "href": "learn-stan/articles.html#bayesian-workflow",
    "title": "Stan",
    "section": "Bayesian Workflow",
    "text": "Bayesian Workflow\n\nWorkflow paper\nAki papers - PSIS-LOO-CV"
  },
  {
    "objectID": "learn-stan/articles.html#books-using-stan",
    "href": "learn-stan/articles.html#books-using-stan",
    "title": "Stan",
    "section": "Books using Stan",
    "text": "Books using Stan\n\nSuzuki, J. 2023. WAIC and WBIC with R Stan: 100 Exercises for Building Logic. Springer.\nMatsuura, K.. 2022. Bayesian Statistical Modeling with Stan, R, and Python. Springer.\nHolmes, E. E., M. D. Scheuerell, and E. J. Ward. 2019. Applied Time Series Analysis for Fisheries and Environmental Sciences. NOAA Fisheries, Northwest Fisheries Science Center.\nHilbe, J. M., R.S. de Souza, and E. E. O. Ishida. 2017. Bayesian Models for Astrophysical Data Using R, JAGS, Python and Stan. Cambridge University Press.\nMatsuura, K.. 2016. Bayesian Statistical Modeling Using Stan and R. Wonderful R Series, Volume 2. Kyoritsu Shuppan Co., Ltd. [in Japanese]\nMcElreath, R. 2016. Statistical Rethinking: A Bayesian Course with R and Stan. Chapman-Hall/CRC.\nKorner-Nievergelt, F., Roth, T., Von Felten, S., Guélat, J., Almasi, B. and Korner-Nievergelt, P. 2015. Bayesian Data Analysis in Ecology Using Linear Models with R, BUGS, and Stan. Academic Press.\nKruschke, J. 2014. Doing Bayesian Data Analysis: A Tutorial with R, JAGS, and Stan. Academic Press.\nGelman, A., Carlin, J.B., Stern, H.S., Dunson, D.B., Vehtari, A. and Rubin, D.B. 2013. Bayesian Data Analysis, Third Edition. Chapman-Hall/CRC."
  },
  {
    "objectID": "learn-stan/field-guides.html",
    "href": "learn-stan/field-guides.html",
    "title": "Specialized Field Guides",
    "section": "",
    "text": "Specialized Field Guides\nTutorials, case studies, software packages, and publications related to specific fields. These pages are maintained by volunteers from the Stan community. If you would like to contribute one for your field please reach out on the Stan forums.\n\nStan for Education Research\nStan for Ecology\nSatan for Epidemiolog\nStan for Cognitive Science\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "mc-stan-org/about.html",
    "href": "mc-stan-org/about.html",
    "title": "About the Stan Project",
    "section": "",
    "text": "Stan is freedom-respecting, open-source software (new BSD core, some interfaces GPLv3).  Stan is associated with NumFOCUS, a 501(c)(3) nonprofit supporting open code and reproducible science, through which you can help support Stan.\n\n\nStan has grown from a small research project started in 2011 at Columbia University to a global community of developers, researchers, and users. The Stan project owes its success to the contributions from hundreds of developers, researchers, active users, and funders. Individual contributions to the software and documentation can be tracked through GitHub.\nStan has been funded through grants for Stan and its developers, through in-kind donations in the form of companies contributing developer time to Stan and individuals contributing their own time to Stan, and through donations to the open-source scientific software non-profit NumFOCUS.\nWe are grateful to all the users who have taken the time to file bug reports and feature requests via the GitHub and the Stan forums; this feedback has greatly improved Stan’s usability and reliability."
  },
  {
    "objectID": "mc-stan-org/about.html#open-code-reproducible-science",
    "href": "mc-stan-org/about.html#open-code-reproducible-science",
    "title": "About the Stan Project",
    "section": "",
    "text": "Stan is freedom-respecting, open-source software (new BSD core, some interfaces GPLv3).  Stan is associated with NumFOCUS, a 501(c)(3) nonprofit supporting open code and reproducible science, through which you can help support Stan.\n\n\nStan has grown from a small research project started in 2011 at Columbia University to a global community of developers, researchers, and users. The Stan project owes its success to the contributions from hundreds of developers, researchers, active users, and funders. Individual contributions to the software and documentation can be tracked through GitHub.\nStan has been funded through grants for Stan and its developers, through in-kind donations in the form of companies contributing developer time to Stan and individuals contributing their own time to Stan, and through donations to the open-source scientific software non-profit NumFOCUS.\nWe are grateful to all the users who have taken the time to file bug reports and feature requests via the GitHub and the Stan forums; this feedback has greatly improved Stan’s usability and reliability."
  },
  {
    "objectID": "mc-stan-org/about.html#stan-user-and-developer-forums",
    "href": "mc-stan-org/about.html#stan-user-and-developer-forums",
    "title": "About the Stan Project",
    "section": "Stan User and Developer Forums",
    "text": "Stan User and Developer Forums\n\nStan forums - message board for questions, discussion, and announcements related to Stan for both users and developers.\nStan slack - developer discussions\nGitHub issues - report bugs"
  },
  {
    "objectID": "mc-stan-org/about.html#licensing",
    "href": "mc-stan-org/about.html#licensing",
    "title": "About the Stan Project",
    "section": "Licensing",
    "text": "Licensing\n\nText content: CC-BY ND 4.0 license\nComputer code: BSD 3-clause license\n\n\nCopyright and trademark\n\nCopyright 2011–2024, Stan Development Team and their assignees.\nThe Stan name and logo are registered trademarks of NumFOCUS.\n\n\n\nUsing the Stan Logo\nThe Stan name and logo are registered trademarks of NumFOCUS under the direction of the Stan Governing Body.\nBoth may be freely used when referencing Stan, for example, in blog posts, lecture notes, or open source software packages, but they may not be used in the branding of commercial entities, such as paid software packages or paid courses, without the express license of the Stan Governing Body. If you have any questions or would like to inquire about licensing the Stan name and/or logo for a commercial venture then please contact NumFOCUS at mailto:admin@numfocus.org.\nThe Stan name and Stan logo may not be used in ways that suggest the usage is endorsed by the Stan project without written permission from the Stan Governing Body.\nWhen using the Stan logo please use one of the following:\n\nStan Logo png\nStan Logo svg"
  },
  {
    "objectID": "mc-stan-org/about.html#citing-stan",
    "href": "mc-stan-org/about.html#citing-stan",
    "title": "About the Stan Project",
    "section": "Citing Stan",
    "text": "Citing Stan\nWe appreciate citations for the Stan software because it lets us find out what people have been doing with Stan and motivate further grant funding.\nWe appreciate citations for the Stan software because it lets us find out what people have been doing with Stan and motivate further grant funding. When citing Stan we recommend citing both Stan itself as well as the particular interface used.\nTo cite Stan itself you can cite the Stan Reference Manual or Stan User’s Guide taking the year and version from the latest release on the Stan Project’s Github releases page: https://github.com/stan-dev/stan/releases.\n\nStan Development Team. YEAR. Stan Reference Manual, VERSION. https://mc-stan.org\nStan Development Team. YEAR. Stan User’s Guide, VERSION. https://mc-stan.org\n\nTo cite the interface or post-processing package you used we recommend using the citation conventions for the language (R, Python, Julia, etc.) associated with the interface or package. For example, to cite RStan use the standard conventions for citing R packages."
  },
  {
    "objectID": "mc-stan-org/about.html#support-stan",
    "href": "mc-stan-org/about.html#support-stan",
    "title": "About the Stan Project",
    "section": "Support Stan",
    "text": "Support Stan\n\nContribute Money\nStan operates through NumFOCUS, a U.S. 501(c)(3) nonprofit organization that serves open-source software projects including NumPy, Julia, Jupyter, ScikitLearn, and many more.\n\nContribute to Stan via NumFOCUS    (Salsa Labs payment processing)\nSponsor Stan via GitHub\n\n\n\nContribute Expertise\nWe welcome new Stan contributors!\n\nCode\nWrite\nHost events"
  },
  {
    "objectID": "mc-stan-org/about.html#shop-for-stan-swag",
    "href": "mc-stan-org/about.html#shop-for-stan-swag",
    "title": "About the Stan Project",
    "section": "Shop for Stan Swag",
    "text": "Shop for Stan Swag\nIf you’re looking to infer in style, stop by one of our shops for Stan t-shirts and mugs.\n\nStan Shop [US]   (Spreadshirt US)\nStan Shop [UK]   (Spreadshirt UK)"
  }
]